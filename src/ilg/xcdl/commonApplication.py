# -*- coding: utf-8 -*-

import os

from ilg.xcdl.errorWithDescription import ErrorWithDescription
from ilg.xcdl.object import Object

from ilg.xcdl.packageLocation import PackageLocation

# WARNING: DO NOT REMOVE the UnusedImport lines!
# They are needed in executed scripts
from ilg.xcdl.configuration import Configuration  # @UnusedImport

from ilg.xcdl.repository import Repository  # @UnusedImport
from ilg.xcdl.package import Package  # @UnusedImport
from ilg.xcdl.component import Component  # @UnusedImport
from ilg.xcdl.interface import Interface  # @UnusedImport
from ilg.xcdl.option import Option  # @UnusedImport

from ilg.xcdl.repositoryFolder import RepositoryFolder  # @UnusedImport

from ilg.xcdl.toolchain import Toolchain  # @UnusedImport
from ilg.xcdl.toolchain import Tool  # @UnusedImport


class CommonApplication(object):

    # static member
    _sourcePathsListDefault = ['src', '.']

    @staticmethod    
    def getSourcePathsListDefault():
        
        return CommonApplication._sourcePathsListDefault

    # static member
    _doNotEditMessage = 'Automatically-generated by the XCDL framework. Do not edit!'

    @staticmethod    
    def getDoNotEditMessage():
        
        return CommonApplication._doNotEditMessage

    # initialise the dictionary where all objects will be stored
    allObjectsByIdDict = {}
    allObjectsByNameDict = {}
    allObjectsBySymbolDict = {}

    @staticmethod    
    def isObjectById(sid):
        
        return sid in CommonApplication.allObjectsByIdDict

    @staticmethod    
    def getObjectById(sid):
        
        return CommonApplication.allObjectsByIdDict[sid]

    @staticmethod    
    def isObjectByName(name):
        
        return name in CommonApplication.allObjectsByNameDict

    @staticmethod    
    def getObjectByName(name):
        
        return CommonApplication.allObjectsByNameDict[name]

    @staticmethod    
    def isObjectBySymbol(name):
        
        return name in CommonApplication.allObjectsBySymbolDict

    @staticmethod    
    def getObjectBySymbol(name):
        
        return CommonApplication.allObjectsBySymbolDict[name]

    @staticmethod    
    def insertObject(node):
        
        # insert node to both dictionaries
        CommonApplication.allObjectsByIdDict[node.getId()] = node
        CommonApplication.allObjectsByNameDict[node.getName()] = node
        
        return
    
    @staticmethod    
    def insertObjectBySymbol(node):
        
        headerDefinition = node.getHeaderDefinition()
        if headerDefinition != None:
            CommonApplication.allObjectsBySymbolDict[headerDefinition] = node
        
        return

    
    verbosity = 0

    @staticmethod    
    def getVerbosity():
        
        return CommonApplication.verbosity
    

    @staticmethod    
    def setVerbosity(verbosity):
        
        CommonApplication.verbosity = verbosity
    
    
    errorCount = 0

    @staticmethod    
    def getErrorCount():
        
        return CommonApplication.errorCount
    

    @staticmethod    
    def clearErrorCount():
    
        CommonApplication.errorCount = 0
        return


    @staticmethod    
    def addToErrorCount(count):
        
        CommonApplication.errorCount += count
        return
    
    
    def __init__(self, *argv):
        
        self.argv = argv
        
        self.verbosity = 0

        self.defaultScripts = ['meta/xcdl.py', 'xcdl.py']
        
        self.indent = '   '

        return
    
    
    def parseRepositories(self, repositoriesAbsolutePathList, minVerbosity):
        
        # build a list of trees, for all given packages
        repositoriesList = []
        
        for repositoryAbsolutePath in repositoriesAbsolutePathList:
            
            packsList = self.parseRepository(repositoryAbsolutePath, minVerbosity)
            if packsList != None:
                repositoriesList.extend(packsList)
        
        return repositoriesList
    

    def parseRepository(self, repoFolderAbsolutePathList, minVerbosity):
                        
        packageAbsolutePath = os.path.abspath(repoFolderAbsolutePathList)

        if os.path.isdir(packageAbsolutePath):
            if self.verbosity > minVerbosity:
                print 'Parse repository folder \'{0}\'...'.format(repoFolderAbsolutePathList)
            
            # keep a list of parsed folders to avoid duplicates 
            parsedFolders = []
            rootList = self.parseFolderRecursive(None, packageAbsolutePath, parsedFolders)
            
        elif os.path.isfile(repoFolderAbsolutePathList):
            if self.verbosity > minVerbosity:
                print 'Parse packages file \'{0}\'....'.format(repoFolderAbsolutePathList)
            # process the given script and recurse
            rootList = self.parseScript(None, packageAbsolutePath)
        else:
            raise ErrorWithDescription("Path not a folder or a file")
        
        for node in rootList:
            node.setRepositoryFolderAbsolutePath(packageAbsolutePath)
            if self.verbosity > 0:
                print '- {0} \'{1}\' parsed in'.format(node.getObjectType().lower(), node.getName())
                        
        return rootList


    def parseConfigurationFile(self, configFilePath, minVerbosity):
        
        if self.verbosity > minVerbosity:
            print 'Parse configuration file \'{0}\'...'.format(configFilePath)
        configFileAbsolutePath = os.path.abspath(self.configFilePath)
        
        localRepositoriesList = []
        RepositoryFolder.setList(localRepositoriesList)
        
        # process the given script and recurse
        configTreesList = self.parseScript(None, configFileAbsolutePath, None)

        for node in configTreesList:
            if self.verbosity > 0:
                print '- configuration \'{0}\' parsed in'.format(node.getName())

        repoFolderAbsolutePathList = []
        for repo in localRepositoriesList:
            repoPath = repo.getFolderPath()
            if os.path.isabs(repoPath):
                repoAbsolutePath = repoPath
            else:
                (configFolderAbsolutePath,_) = os.path.split(configFileAbsolutePath)
                repoAbsolutePath = os.path.abspath(os.path.join(configFolderAbsolutePath, repoPath))

            if os.path.isdir(repoAbsolutePath):
                repoFolderAbsolutePathList.append(repoAbsolutePath)
                if self.verbosity > 0:
                    print '- repository folder \'{0}\' added to list'.format(repoAbsolutePath)
            elif os.path.isfile(repoAbsolutePath):
                repoFolderAbsolutePathList.append(repoAbsolutePath)
                if self.verbosity > 0:
                    print '- repository package file \'{0}\' added to list'.format(repoAbsolutePath)
            else:
                print 'ERROR: path \'{0}\' does not exist, ignored'.format(repoAbsolutePath)

        return (configTreesList, repoFolderAbsolutePathList)
    
    
    def parseFolderRecursive(self, parent, folderAbsolutePath, parsedFolders):
        
        crtParent = parent
        localList = []
        for path in self.defaultScripts:
            tentativeFileAbsolutePath = os.path.join(folderAbsolutePath, path)
            if os.path.isfile(tentativeFileAbsolutePath):
                if self.verbosity > 2:
                    print 'is package'
                
                (tentativeFolderAbsolutePath,_) = os.path.split(tentativeFileAbsolutePath)
                if tentativeFolderAbsolutePath not in parsedFolders:
                    packageLocation = PackageLocation(folderAbsolutePath, tentativeFileAbsolutePath)
                    localList = self.parseScript(parent, tentativeFileAbsolutePath, packageLocation)
                    if len(localList) > 0:
                        crtParent = localList[0]
                    parsedFolders.append(tentativeFolderAbsolutePath)
                break
                 
        for name in os.listdir(folderAbsolutePath):
            absolutePath = os.path.join(folderAbsolutePath, name)
            if os.path.isdir(absolutePath):
                if self.verbosity > 2:
                    print 'subfolder {0}'.format(absolutePath)
                self.parseFolderRecursive(crtParent, absolutePath, parsedFolders)
        
        return localList
    
    
    def parseScript(self, parent, scriptAbsolutePath, packageLocation):
        
        if self.verbosity > 0:
            print '- parse file {0}'.format(scriptAbsolutePath)
        
        # list used to collect all objects contributed by encountered 
        # constructors
        localList = []
        Object.setList(localList)
        
        if not os.path.isfile(scriptAbsolutePath):
            raise ErrorWithDescription('Missing script file \'{0}\''.
                                       format(scriptAbsolutePath))
        
        try:
            execfile(scriptAbsolutePath)
        except BaseException as err:
            raise ErrorWithDescription('\'{0}\' in file \'{1}\''.format(err, scriptAbsolutePath))
                
        self.warnNonParsedKeywords(localList)
        
        # manual links to children or to parent
        localList = self.linkChildrenNodes(localList)
        localList = self.linkNodesWithParent(localList)
        
        # process parsed nodes
        for obj in localList:            
            self.processNode(obj, parent, scriptAbsolutePath, packageLocation)
            
        # return the current list, useful for the root node,
        # all other use the parent to build the tree                    
        return localList


    def warnNonParsedKeywords(self, localList):

        for node in localList:            

            # warn if some of the keywords were not parsed
            if len(node.getNonRecognisedKeywords()) > 0:
                print 'Ignored keywords {0} in {1}'.format(
                        node.getNonRecognisedKeywords(), node.getId())
        
        return
        

    def linkChildrenNodes(self, localList):
                
        for node in localList:
            
            if node.getChildrenList() == None:
                continue
                
            # print 'has children {0}'.format(node.getId())
            for child in node.getChildrenList():
                # print 'child {0}'.format(child.getId())
                
                # link-up to parent
                child.setTreeParent(node)
                # link-down to child
                node.addTreeChild(child)
            
        shortList = []
        for node in localList:
            
            # non-linked nodes will be processed further
            if node.getTreeParent() == None:
                shortList.append(node)
                        
        return shortList
    

    def linkNodesWithParent(self, localList):
        
        oldList = localList
        while True:
            
            newList = []
            
            for node in oldList:
                
                parentName = node.getParentId()
                if parentName == None:
                    newList.append(node)
                    continue
                
                # this node has a parent definition
                
                found = False
                for parentNode in oldList:                    
                    if parentName == parentNode.getId():
                        found = True
                        break
                    
                # if it's parent is not know, continue                
                if not found:
                    newList.append(node)
                    continue                    
                
                # if the node parent is known, link to it
                node.setTreeParent(parentNode)
                parentNode.addTreeChild(node)
                # do not pass it to new list
            
            if len(oldList) == len(newList):
                break
            
            oldList = newList
            
        return newList
    
    
    def processNode(self, node, parent, scriptAbsolutePath, packageLocation):
        
        # check if the id was already used
        if  CommonApplication.isObjectById(node.getId()):
                
            oldObject = CommonApplication.getObjectById(node.getId())
            oldName = oldObject.getName()
            oldDescription = oldObject.getDescription()
            
            if (oldName == node.getName()) and (oldDescription == node.getDescription()):
                return
            
            raise ErrorWithDescription('Id \'{0}\' \'{1}\' redefined (was \'{2}\')'.
                            format(node.getId(), node.getName(), oldName))

        # check if the name was already used
        if  CommonApplication.isObjectByName(node.getName()):
                
            oldObject = CommonApplication.getObjectByName(node.getName())
            oldId = oldObject.getId()
            oldDescription = oldObject.getDescription()
            
            if (oldId == node.getId()) and (oldDescription == node.getDescription()):
                return
            
            raise ErrorWithDescription('Name \'{0}\' \'{1}\' redefined (was \'{2}\')'.
                            format(node.getName(), node.getId(), oldId))
              
        # eventually process local parent
        parentNodeId = node.getParentId()
        if parentNodeId != None and parent != None:
            if parent.getId() != parentNodeId:
                print 'Parent of {0} already is {1}, redefined as {2}, ignored'.format(
                                node.getId(), parent.getId(), parentNodeId)
            parentNodeId = None
            
        if parentNodeId != None:
            
            # compute parent object from parent name
            if  not CommonApplication.isObjectById(parentNodeId):
                # TODO: check if possible to use a deferred list
                raise ErrorWithDescription('Parent {0} not defined'.
                                               format(parentNodeId))
                    
            crtParent = CommonApplication.getObjectById(parentNodeId)
        else:
            crtParent = parent

        if node.getTreeParent() == None:
            
            # up-link from the current object to the given parent
            node.setTreeParent(crtParent)
            
            # down-link from the parent to the current object
            if crtParent != None:
                crtParent.addTreeChild(node)

        # remember the current package location
        if node.getPackageLocation() == None:
            node.setPackageLocation(packageLocation)
                        
        # store current object in the global dictionary    
        CommonApplication.insertObject(node)
        
        # process inner scripts        
        scriptsList = node.getIncludesList()
        if scriptsList != None:
                
            (baseAbsolutePath, _) = os.path.split(scriptAbsolutePath)
                                
            for child in scriptsList:
                    
                # print child
                childAbsolutePath = os.path.abspath(os.path.join(
                                                baseAbsolutePath, child))
                # print childAbsolutePath
                    
                self.parseScript(node, childAbsolutePath, packageLocation)
                
        
        # process children nodes recursively
        # children were moved to tree by linkChildrenNodes()
        childrenList = node.getTreeChildrenList()
        if childrenList != None:
            
            for child in childrenList:
                self.processNode(child, node, scriptAbsolutePath, packageLocation)

        return
    
    
    def dumpTree(self, repositoriesList, isLoaded):
        
        if not isLoaded:
            print "The repositories full trees:"
        else:
            print "The loaded repositories nodes:"
        
        print
        for tree in repositoriesList:
            self.dumpTreeRecursive(tree, 0, isLoaded)
        return
    
        
    def dumpTreeRecursive(self, node, depth, isLoaded):
        
        if isLoaded and (not node.isLoaded()):
            return
        
        indent = '   '
        objectType = node.getObjectType()
        
        kind = ' ({0}'.format(objectType)
        if node.getCategory() != None:
            kind += ',{0}'.format(node.getCategory())
        if node.getValueType() != None:
            kind += ',{0}'.format(node.getValueType())
        kind += ')'
        
        if objectType not in ['Toolchain']:
            kind += (' +E' if node.isEnabled() else ' -E')
            kind += (' +A' if node.isActive() else ' -A')
        
        print '{0}* {1} \'{2}\'{3}'.format(indent * depth, node.getId(),
                            node.getName(), kind)

        if objectType not in ['Toolchain']:
            
            packageLocation = node.getPackageLocation()
            if packageLocation != None:
                print '{0}- packageFolder \'{1}\''.format(indent * (depth + 1),
                                        packageLocation.getFolderAbsolutePath())
                
            # dump sources, if any
            sourcesList = node.getSourceFilesList()
            if sourcesList != None:
                for source in sourcesList:
                    print '{0}- sourceFile {1}'.format(indent * (depth + 1), source)
    
            # dump loadPackages, if any
            loadPackagesList = node.getLoadPackagesList()
            if loadPackagesList != None:
                for loadPackages in loadPackagesList:
                    print '{0}- loadPackage {1}'.format(indent * (depth + 1), loadPackages)
                    
            headerDefinition = node.getHeaderDefinition()
            if headerDefinition != None:
                print '{0}- headerDefinition {1}'.format(indent * (depth + 1), headerDefinition)
                   
            headerPath = node.getHeaderFile()
            if headerPath != None:
                print '{0}- headerFile \'{1}\''.format(indent * (depth + 1), headerPath)
        
        else:
            toolsDict = node.getToolsDict()
            for key in toolsDict:
                tool = toolsDict[key]
                print '{0}- tool {1} \'{2}\' '.format(indent * (depth + 1), key, tool.getDescription())
            
            compilerOptimisationOptions = node.getProperty('compilerOptimisationOptions')
            if compilerOptimisationOptions != None:
                print '{0}- compilerOptimisationOptions \'{1}\' '.format(indent * (depth + 1), compilerOptimisationOptions)
                 
            compilerMiscOptions = node.getProperty('compilerMiscOptions')
            if compilerMiscOptions != None:
                print '{0}- compilerMiscOptions \'{1}\' '.format(indent * (depth + 1), compilerMiscOptions)
                
        children = node.getTreeChildrenList()
        if children == None:
            return
        
        # iterate through all children
        for child in children:           
            self.dumpTreeRecursive(child, depth + 1, isLoaded)            
            
        return

    
    def dumpConfiguration(self, configTreesList):
        
        print "The configuration trees:"
        print
        for tree in configTreesList:
            self.dumpConfigurationRecursive(tree, 0)
        return
    
        
    def dumpConfigurationRecursive(self, node, depth):
        
        indent = self.indent
        kind = ' ({0})'.format(node.getObjectType())
            
        print '{0}* {1} \'{2}\'{3}'.format(indent * depth, node.getId(),
                            node.getName(), kind)

        # dump loadPackages, if any
        loadPackagesList = node.getLoadPackagesList()
        if loadPackagesList != None:
            for loadPackages in loadPackagesList:
                print '{0}- loadPackages {1}'.format(indent * (depth + 1), loadPackages)
        
        optionsList = node.getOptionsList()
        if optionsList != None and len(optionsList) > 0:
            for key in optionsList.keys():
                print'{0}- option {1}={2}'.format(indent * (depth + 1), key,
                                                  optionsList[key])
                     
        buildFolder = node.getBuildFolder()
        if buildFolder != None:
            print'{0}- buildFolder=\'{1}\''.format(indent * (depth + 1), buildFolder)

        preprocessorSymbols = node.getPreprocessorSymbolsList()
        if preprocessorSymbols != None:
            for preprocessorSymbol in preprocessorSymbols:
                print '{0}- preprocessorSymbol=\'{1}\''.format(indent * (depth + 1),
                                                            preprocessorSymbol)
                    
        toolchainId = node.getToolchainId()
        if toolchainId != None:
            print'{0}- toolchain=\'{1}\''.format(indent * (depth + 1), toolchainId)
            
        children = node.getTreeChildrenList()
        if children == None:
            return
        
        # iterate through all children
        for child in children:           
            self.dumpConfigurationRecursive(child, depth + 1)
                        
        return

    
    def loadConfiguration(self, configTreesList, sid, minVerbosity):
        
        if not CommonApplication.isObjectById(sid):
            raise ErrorWithDescription('Missing configuration node id=\'{0}\', cancelled'.format(sid))
        
        configNode = CommonApplication.getObjectById(sid)
        if self.verbosity > minVerbosity:
            print 'Load configuration node \'{0}\'...'.format(configNode.getName())
        
        self.loadConfigNode(configNode, 0)
        #updated = self.loadConfigNode(configNode, 0)
        #print '- {0} nodes loaded'.format(updated)

        return configNode
    
    
    def loadConfigNode(self, configNode, depth):
        
        if configNode.getObjectType() != 'Configuration':
            raise ErrorWithDescription('Not a configuration node {0}'.format(configNode.getName()))
        
        indent = self.indent
        if self.verbosity > 1:
            print '{0}process {1}'.format(indent * depth, configNode.getId())

        updated = 0
        loadList = configNode.getLoadPackagesList()
        if loadList != None:
            for load in loadList:
                updated += self.loadPackageTreeNode(load, depth+1)
        
        treeParent = configNode.getTreeParent()
        if treeParent != None:
            if treeParent.getObjectType() != 'Configuration':
                updated += self.loadPackageTreeNode(treeParent.getId(), depth+1)
            else:
                updated += self.loadConfigNode(treeParent, depth+1)
               
        return updated
    
                
    def loadPackageTreeNode(self, treeNodeId, depth):

        if  not  CommonApplication.isObjectById(treeNodeId):
            raise ErrorWithDescription('Missing node to load {0}'.format(treeNodeId))
        
        indent = self.indent

        treeNode = CommonApplication.getObjectById(treeNodeId)
        if treeNode.getObjectType() == 'Configuration':
            updated = self.loadConfigNode(treeNode, depth+1)
            return updated
        
        treePackageNode = treeNode.getPackageTreeNode()
        if treePackageNode == None:
            updated = 0
            return updated
        
        if self.verbosity == 1:
            print '- package \'{0}\' and parents loaded'.format(treePackageNode.getName())
        elif self.verbosity > 1:
            print '{0}load {1}'.format(indent * depth, treeNodeId)
            
        updated = treePackageNode.setIsLoadedRecursive()
        
        loadPackagesList = treePackageNode.getLoadPackagesList()
        if loadPackagesList != None:
            for loadPackages in loadPackagesList:
                updated += self.loadPackageTreeNode(loadPackages, depth+1)
                        
        return updated
    
    
    def dumpPreprocessorDefinitions(self, repositoriesList):
        
        print "The preprocessor definitions:"
        
        headersDict = self.buildHeadersDict(repositoriesList)
        for key in headersDict.iterkeys():
            headerLines = headersDict[key]
            print
            print key
            for headerLine in headerLines:
                print headerLine
            
        return
    

    def buildHeadersDict(self, repositoriesList):
        
        headersDict = {}
        for tree in repositoriesList:
            self.buildHeadersDictRecursive(tree, 0, headersDict)
            
        return headersDict

    
    def buildHeadersDictRecursive(self, node, depth, headersDict):

        if not node.isLoaded():
            return
        
        headerLineAndFileName = node.getHeaderLineAndFileName()
        if headerLineAndFileName != None:
            
            (headerDefinition, headerFile) = headerLineAndFileName
            
            if self.verbosity > 1:
                print 'process {0}'.format(node.getId())

                print 'file: \'{0}\''.format(headerFile)
                print headerDefinition
                print
             
            if headerFile not in headersDict:
                headersDict[headerFile] = []
                 
            headersDict[headerFile].append(headerDefinition)
            
        children = node.getTreeChildrenList()
        if children == None:
            return
        
        # iterate through all children
        for child in children:           
            self.buildHeadersDictRecursive(child, depth + 1, headersDict)            
        
        return
    
    
    def dumpSourceFiles(self, repositoriesList):
        
        print "The source files to compile:"
        
        sourcesDict = self.buildSourcesDict(repositoriesList)
        for key in sourcesDict.iterkeys():
            sources = sourcesDict[key]
            print
            print key
            for source in sources:
                print '   source {0}, from node \'{1}\''.format(source['fileName'], source['repoNode'].getName())
            
        return
    

    def buildSourcesDict(self, repositoriesList):

        sourcesDict = {}
        for tree in repositoriesList:
            self.buildSourcesDictRecursive(tree, 0, sourcesDict)
            
        return sourcesDict

    
    def buildSourcesDictRecursive(self, node, depth, sourcesDict):
        
        if not node.isLoaded():
            return
        
        if node.isActive():
            
            sourceFiles = node.getSourceFilesList()
            if sourceFiles != None:
            
                if self.verbosity > 1:
                    print 'process {0}'.format(node.getId())

                packageFolder = node.getPackageLocation().getFolderAbsolutePath()
                #if self.verbosity:
                #    print 'package folder: \'{0}\''.format(packageFolder)

                treeRoot = node.getTreeRoot()
                buildSubFolder = treeRoot.getBuildSubFolderWithDefault()
                #if self.verbosity:
                #    print 'build subfolder: \'{0}\''.format(buildSubFolder)
                
                rootPackageFolder = treeRoot.getPackageLocation().getFolderAbsolutePath()
                #if self.verbosity:
                #    print 'root package folder: \'{0}\''.format(rootPackageFolder)
                
                sourcesPathsList = node.getSourcePathsListRecursive()
                if sourcesPathsList == None:
                    sourcesPathsList = CommonApplication.getSourcePathsListDefault()
                
                      
                for sourceFile in sourceFiles:
                    if self.verbosity > 1:
                        print 'source file: \'{0}\''.format(sourceFile)

                    foundSourcePath = None
                    for sourcePath in sourcesPathsList:
                        sourceAbsolutePath = os.path.join(packageFolder, sourcePath, sourceFile)
                        if os.path.isfile(sourceAbsolutePath):
                            if self.verbosity > 1:
                                print 'source file path: \'{0}\''.format(sourceAbsolutePath)
                            foundSourcePath = sourcePath
                            break
                        
                    if foundSourcePath == None:
                        print 'not found'
                        continue
                    
                    if not sourceAbsolutePath.startswith(rootPackageFolder):
                        print 'paths do not match'
                        continue
                    
                    subPath = sourceAbsolutePath[len(rootPackageFolder)+1:]
                    #print subPath
                    subPathList = subPath.split(os.sep)
                    #print subPathList
                    
                    buildPathList = []
                    buildPathList.append(buildSubFolder)
                    buildPathList.extend(subPathList[:-1])
                    
                    buildPathString = os.sep.join(buildPathList)
                    if self.verbosity > 1:
                        print 'build path: {0}'.format(buildPathString)
                    
                    if buildPathString not in sourcesDict:
                        # add an empty list for this build path
                        sourcesDict[buildPathString] = []
                    
                    crtSourceDict = {}
                    crtSourceDict['fileName'] = sourceFile
                    crtSourceDict['buildPathList'] = buildPathList
                    crtSourceDict['sourceAbsolutePath'] = sourceAbsolutePath
                    crtSourceDict['repoNode'] = node
                    
                    # append the current source file to the path
                    sourcesDict[buildPathString].append(crtSourceDict)
                if self.verbosity > 1:
                    print
             
        children = node.getTreeChildrenList()
        if children == None:
            return
        
        # iterate through all children
        for child in children:           
            self.buildSourcesDictRecursive(child, depth + 1, sourcesDict)            
        
        return
    
    
    def processInitialIsEnabled(self, repositoriesList):
    
        while True:
            count = 0
            for tree in repositoriesList:
                count += self.processInitialIsEnabledRecursive(tree, 0)
                            
            if count == 0:
                break
            
        return


    def processInitialIsEnabledRecursive(self, node, depth):

        count = 0
        initialIsEnabled = node.getInitialIsEnabled()
        if initialIsEnabled != None:
            if not isinstance(initialIsEnabled, bool):
                # boolean values were already processed in constructor
                try:
                    evaluatedValue = eval(initialIsEnabled)
                except:
                    evaluatedValue = True if initialIsEnabled else False
                
                count += node.setIsEnabledWithCount(evaluatedValue)
                    
                if count > 0 and self.verbosity > 0:
                    status = 'enabled' if evaluatedValue else 'disabled'
                    print '- {0} \'{1}\' initially {2}'.format(node.getObjectType().lower(), node.getName(), status)
            
        children = node.getTreeChildrenList()
        if children == None:
            return count
    
        # iterate through all children
        for child in children:           
            count += self.processInitialIsEnabledRecursive(child, depth + 1)            

        return count


    def processRequiresProperties(self, repositoriesList, configNode, doReport):
    
        while True:
            clearGlobalCount()
            
            # first process the configuration requirements
            self.processConfigRequiresRecursive(configNode, 0, doReport)
            
            # than the packages trees
            for tree in repositoriesList:
                self.processTreeRequiresRecursive(tree, 0, doReport)
                self.processImplementsPropertiesRecursive(tree, 0)
                            
            if getGlobalCount() == 0:
                break
            
        return


    def processTreeRequiresRecursive(self, node, depth, doReport):

        if not node.isLoaded():
            return

        if not node.isEnabled():
            return
        
        requiresList = node.getRequiresList()
        if requiresList != None:
            
            for requires in requiresList:
                if not eval(requires):
                    # count errors
                    CommonApplication.addToErrorCount(1)
                    if doReport:
                        print ('ERROR: Requirement \'{0}\' not satisfied for node \'{1}\''.
                               format(requires, node.getName()))
            
        children = node.getTreeChildrenList()
        if children == None:
            return 
    
        # iterate through all children
        for child in children:           
            self.processTreeRequiresRecursive(child, depth + 1, doReport)            

        return


    def processConfigRequiresRecursive(self, node, depth, doReport):

        requiresList = node.getRequiresList()
        if requiresList != None:
            
            for requires in requiresList:
                if not eval(requires):
                    if doReport:
                        print ('ERROR: Requirement \'{0}\' not satisfied for node \'{1}\''.
                               format(requires, node.getName()))

        parentNode = node.getTreeParent()
        if parentNode == None:
            return
        
        return self.processConfigRequiresRecursive(parentNode, depth+1, doReport)



    def processImplementsPropertiesRecursive(self, node, depth):

        if not node.isLoaded():
            return

        if not node.isEnabled():
            return
        
        implementsList = node.getImplementsList()
        if implementsList != None:
            
            for sid in implementsList:
                if not CommonApplication.isObjectById(sid):
                    print 'ERROR: Missing id=\'{0}\', \'implements\' property ignored'.format(sid)
                    
                interfaceNode = CommonApplication.getObjectById(sid)
                if interfaceNode.getObjectType() != 'Interface':
                    print 'ERROR: Node id=\'{0}\', not an interface, \'implements\' property ignored'.format(sid)
                
                # finally add the current node to the interface implementations list    
                count = interfaceNode.addImplementationWithCount(node.getId())
                if count > 0:
                    if self.verbosity > 0:
                        print '- {0} \'{1}\' implements \'{2}\''.format(
                                    node.getObjectType().lower(), node.getName(), 
                                    interfaceNode.getName())
                    addToGlobalCount(count)
                           
        children = node.getTreeChildrenList()
        if children == None:
            return 
    
        # iterate through all children
        for child in children:           
            self.processImplementsPropertiesRecursive(child, depth + 1)            

        return


    def processSymbolsDict(self, repositoriesList):
    
        count = 0
        for tree in repositoriesList:
            count += self.processSymbolsDictRecursive(tree, 0)
            
        return count


    def processSymbolsDictRecursive(self, node, depth):

        count = 0
        
        if not node.isLoaded():
            return count

        headerDefinition = node.getHeaderDefinition()
        if headerDefinition != None:

            if CommonApplication.isObjectBySymbol(headerDefinition):
                firstDefinition = CommonApplication.getObjectBySymbol(headerDefinition)
                print 'ERROR: Preprocessor symbol {0} redefined in \'{1}\' (first definition in {2})'.format(headerDefinition, node.getName(), firstDefinition.getName())
            else:
                CommonApplication.insertObjectBySymbol(node)
                count += 1
                
        children = node.getTreeChildrenList()
        if children == None:
            return count
    
        # iterate through all children
        for child in children:           
            count += self.processSymbolsDictRecursive(child, depth + 1)            

        return count


# ----- functions used in xcdl expressions ------------------------------------

globalCount = 0

def clearGlobalCount():
    
    global globalCount
    globalCount = 0
    return


def getGlobalCount():
    
    global globalCount
    return globalCount

def addToGlobalCount(value):

    global globalCount
    globalCount += value
    return
    
    
def enable(sid):
        
    if CommonApplication.getVerbosity() > 1:
        print 'enable("{0}")'.format(sid)
        
    if CommonApplication.isObjectById(sid):
        node = CommonApplication.getObjectById(sid)
    else:
        if CommonApplication.isObjectBySymbol(sid):
            node = CommonApplication.getObjectBySymbol(sid)
        else:  
            print 'ERROR: Node not found, enable("{0}") ignored'.format(sid)
            return False
    
    if not node.isLoaded():
        print 'ERROR: Node \'{0}\' is not loaded, enable("{1}") ignored'.format(node.getName(), sid)
        return False

    if not node.isConfigurableEvaluated():
        print 'ERROR: Node \'{0}\' is not configurable, enable("{1}") ignored'.format(node.getName(), sid)
        return False
        
    count = node.setIsEnabledWithCount()

    if count > 0 and CommonApplication.getVerbosity() > 0:
        symbolName = node.getHeaderDefinition()
        if symbolName != None:
            print '- {0} \'{1}\'/{2} enabled'.format(node.getObjectType().lower(), node.getName(), symbolName)
        else:
            print '- {0} \'{1}\' enabled'.format(node.getObjectType().lower(), node.getName())
        
    addToGlobalCount(count)
    
    return True


def disable(sid):
        
    if CommonApplication.isObjectById(sid):
        node = CommonApplication.getObjectById(sid)
    else:   
        if CommonApplication.isObjectBySymbol(sid):
            node = CommonApplication.getObjectBySymbol(sid)
        else:  
            print 'ERROR: Node not found, disable("{0}") ignored'.format(sid)
            return False
    
    if not node.isLoaded():
        print 'ERROR: Node \'{0}\' is not loaded, disable("{1}") ignored'.format(node.getName(), sid)
        return False

    if not node.isConfigurableEvaluated():
        print 'ERROR: Node \'{0}\' is not configurable, disable("{1}") ignored'.format(node.getName(), sid)
        return False
        
    count = node.setIsEnabledWithCount(False)

    if count > 0 and CommonApplication.getVerbosity() > 0:
        symbolName = node.getHeaderDefinition()
        if symbolName != None:
            print '- {0} \'{1}\'/{2} disabled'.format(node.getObjectType().lower(), node.getName(), symbolName)
        else:
            print '- {0} \'{1}\' disabled'.format(node.getObjectType().lower(), node.getName())
        
    addToGlobalCount(count)
    
    return True


def isEnabled(sid):
        
    if CommonApplication.isObjectById(sid):
        node = CommonApplication.getObjectById(sid)
    else:
        if CommonApplication.isObjectBySymbol(sid):
            node = CommonApplication.getObjectBySymbol(sid)
        else:  
            print 'ERROR: Node not found, isEnabled("{0}") return False'.format(sid)
            return False
        
    return node.isEnabled()


def isActive(sid):
        
    if CommonApplication.isObjectById(sid):
        node = CommonApplication.getObjectById(sid)
    else:
        if CommonApplication.isObjectBySymbol(sid):
            node = CommonApplication.getObjectBySymbol(sid)
        else:  
            print 'ERROR: Node not found, isActive("{0}") return False'.format(sid)
            return False
        
    return node.isActive()


def valueOf(sid):
        
    if CommonApplication.isObjectById(sid):
        node = CommonApplication.getObjectById(sid)
    else:
        if CommonApplication.isObjectBySymbol(sid):
            node = CommonApplication.getObjectBySymbol(sid)
        else:  
            print 'ERROR: Node not found, valueOf("{0}") return 0'.format(sid)
            return False
        
    return node.getValueWithType()


def setValue(sid, value):
        
    if CommonApplication.getVerbosity() > 1:
        print 'setValue("{0}", \'{1}\')'.format(sid, value)

    if CommonApplication.isObjectById(sid):
        node = CommonApplication.getObjectById(sid)
    else:  
        if CommonApplication.isObjectBySymbol(sid):
            node = CommonApplication.getObjectBySymbol(sid)
        else:  
            print 'ERROR: Node not found, setValue("{0}") ignored'.format(sid)
            return False
    
    if not node.isConfigurableEvaluated():
        print 'ERROR: Node \'{0}\' is not configurable, setValue("{1}") ignored'.format(node.getName(), sid)
        return False

    if node.getValueTypeWithDefault() == 'none':
        print 'ERROR: Node \'{0}\' has valueType=\'none\', setValue("{1}") ignored'.format(node.getName(), sid)
        return False
    
    count = node.setValueWithCount(value)
    
    if count > 0 and CommonApplication.getVerbosity() > 0:
        symbolName = node.getHeaderDefinition()
        if symbolName != None:
            print '- {0} \'{1}\'/{2} set to "{3}"'.format(node.getObjectType().lower(), node.getName(), symbolName, value)
        else:
            print '- {0} \'{1}\' set to "{2}"'.format(node.getObjectType().lower(), node.getName(), value)

    addToGlobalCount(count)
    
    return True


def implementationsOf(sid):
    
    if CommonApplication.getVerbosity() > 1:
        print 'implementationsOf("{0}")'.format(sid)

    if not CommonApplication.isObjectById(sid):
        print 'ERROR: Node not found, implementationsOf("{0}") returns 0'.format(sid)
        return 0
    
    node = CommonApplication.getObjectById(sid)
    if node.getObjectType() != 'Interface':
        print 'ERROR: Node \'{0}\' not an interface, implementationsOf("{1}") returns 0'.format(node.getName(), sid)
        return 0
        
    return node.getValue()




