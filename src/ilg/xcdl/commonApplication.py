# -*- coding: utf-8 -*-

import os
import shutil

from ilg.xcdl.errorWithDescription import ErrorWithDescription
from ilg.xcdl.node import Node

from ilg.xcdl.packageLocation import PackageLocation

# WARNING: DO NOT REMOVE the UnusedImport lines!
# They are needed in executed scripts
from ilg.xcdl.configuration import Configuration  # @UnusedImport

from ilg.xcdl.repository import Repository  # @UnusedImport
from ilg.xcdl.package import Package  # @UnusedImport
from ilg.xcdl.component import Component  # @UnusedImport
from ilg.xcdl.interface import Interface  # @UnusedImport
from ilg.xcdl.option import Option  # @UnusedImport

from ilg.xcdl.repositoryFolder import RepositoryFolder  # @UnusedImport

from ilg.xcdl.toolchain import Toolchain  # @UnusedImport
from ilg.xcdl.toolchain import Tool  # @UnusedImport


class CommonApplication(object):

    # static member
    _sourcePathsListDefault = ['src', '.']

    @staticmethod    
    def getSourcePathsListDefault():
        
        return CommonApplication._sourcePathsListDefault

    # -------------------------------------------------------------------------    
    # static member
    _doNotEditMessage = 'Automatically-generated by the XCDL framework. Do not edit!'

    @staticmethod    
    def getDoNotEditMessage():
        
        return CommonApplication._doNotEditMessage

    # -------------------------------------------------------------------------    
    # initialise the dictionary where all objects will be stored
    allObjectsByIdDict = {}
    allObjectsByNameDict = {}
    allObjectsBySymbolDict = {}

    
    @staticmethod    
    def isObjectById(sid):
        
        return sid in CommonApplication.allObjectsByIdDict

    @staticmethod    
    def getObjectById(sid):
        
        return CommonApplication.allObjectsByIdDict[sid]

    @staticmethod    
    def isObjectByName(name):
        
        return name in CommonApplication.allObjectsByNameDict

    @staticmethod    
    def getObjectByName(name):
        
        return CommonApplication.allObjectsByNameDict[name]

    @staticmethod    
    def isObjectBySymbol(name):
        
        return name in CommonApplication.allObjectsBySymbolDict

    @staticmethod    
    def getObjectBySymbol(name):
        
        return CommonApplication.allObjectsBySymbolDict[name]

    @staticmethod    
    def insertObject(node):
        
        # insert node to both dictionaries
        CommonApplication.allObjectsByIdDict[node.getId()] = node
        CommonApplication.allObjectsByNameDict[node.getName()] = node
        
        return
    
    @staticmethod    
    def insertObjectBySymbol(node):
        
        headerDefinition = node.getHeaderDefinition()
        if headerDefinition != None:
            CommonApplication.allObjectsBySymbolDict[headerDefinition] = node
        
        return

    # -------------------------------------------------------------------------    
    # static member
    allConfigurationsByNameDict = {}

    @staticmethod    
    def insertConfigurationByName(node):
        
        configuratioName = node.getBuildConfigurationName()
        if configuratioName != None:
            CommonApplication.allConfigurationsByNameDict[configuratioName] = node
        
        return

    @staticmethod    
    def isConfigurationByName(name):
        
        return name in CommonApplication.allConfigurationsByNameDict

    @staticmethod    
    def getConfigurationByName(name):
        
        return CommonApplication.allConfigurationsByNameDict[name]

    # -------------------------------------------------------------------------    
    # static member
    verbosity = 0

    @staticmethod    
    def getVerbosity():
        
        return CommonApplication.verbosity
    

    @staticmethod    
    def setVerbosity(verbosity):
        
        CommonApplication.verbosity = verbosity
    
    
    # -------------------------------------------------------------------------    
    # static member
    errorCount = 0

    @staticmethod    
    def getErrorCount():
        
        return CommonApplication.errorCount
    

    @staticmethod    
    def clearErrorCount():
    
        CommonApplication.errorCount = 0
        return


    @staticmethod    
    def addToErrorCount(count=1):
        
        CommonApplication.errorCount += count
        return


    @staticmethod    
    def reportError(stre):
        print 'ERROR: {0}'.format(stre)
        CommonApplication.addToErrorCount()
        
        return
    
    # -------------------------------------------------------------------------    
    # static member
    maxScriptUpdateTime = 0.0
    
    # -------------------------------------------------------------------------    
    def __init__(self, *argv):
        
        self.argv = argv
        
        self.verbosity = 0

        self.defaultScripts = ['meta/xcdl.py', 'xcdl.py']
        
        self.indent = '   '

        return
   
    
    def parseRepositories(self, repositoriesAbsolutePathList, minVerbosity):
        
        # build a list of trees, for all given packages
        repositoriesList = []
        
        for repositoryAbsolutePath in repositoriesAbsolutePathList:
            
            packsList = self.parseRepository(repositoryAbsolutePath, minVerbosity)
            if packsList != None:
                repositoriesList.extend(packsList)
        
        return repositoriesList
    

    def parseRepository(self, repoFolderAbsolutePathList, minVerbosity):
                        
        packageAbsolutePath = os.path.abspath(repoFolderAbsolutePathList)

        rootList = []
        if os.path.isdir(packageAbsolutePath):
            if self.verbosity > minVerbosity:
                print 'Parse repository folder \'{0}\'...'.format(repoFolderAbsolutePathList)
            
            # keep a list of parsed folders to avoid duplicates 
            parsedFolders = []
            rootList = self.parseFolderRecursive(None, packageAbsolutePath, parsedFolders)
            
        elif os.path.isfile(repoFolderAbsolutePathList):
            if self.verbosity > minVerbosity:
                print 'Parse packages file \'{0}\'....'.format(repoFolderAbsolutePathList)
            # process the given script and recurse
            rootList = self.parseScript(None, packageAbsolutePath)
        else:
            raise ErrorWithDescription("Path not a folder or a file")

        if len(rootList) == 0:
            raise ErrorWithDescription("Path does not contain a repository")
        
        for node in rootList:
            if node.getObjectType() != 'Repository':
                raise ErrorWithDescription("Path does not contain a repository")
            
        for node in rootList:
            node.setRepositoryFolderAbsolutePath(packageAbsolutePath)
            if self.verbosity > 0:
                print '- {0} \'{1}\' parsed in'.format(node.getObjectType().lower(), node.getName())
                        
        return rootList


    def parseConfigurationFile(self, configFilePath, minVerbosity):
        
        if self.verbosity > minVerbosity:
            print 'Parse configuration file \'{0}\'...'.format(configFilePath)
        configFileAbsolutePath = os.path.abspath(self.configFilePath)
        
        localRepositoriesList = []
        RepositoryFolder.setList(localRepositoriesList)
        
        # process the given script and recurse
        configTreesList = self.parseScript(None, configFileAbsolutePath, None)

        for node in configTreesList:
            if self.verbosity > 0:
                print '- configuration \'{0}\' parsed in'.format(node.getName())

        repoFolderAbsolutePathList = []
        for repo in localRepositoriesList:
            repoPath = repo.getFolderPath()
            if os.path.isabs(repoPath):
                repoAbsolutePath = repoPath
            else:
                (configFolderAbsolutePath, _) = os.path.split(configFileAbsolutePath)
                repoAbsolutePath = os.path.abspath(os.path.join(configFolderAbsolutePath, repoPath))

            if os.path.isdir(repoAbsolutePath):
                repoFolderAbsolutePathList.append(repoAbsolutePath)
                if self.verbosity > 0:
                    print '- repository folder \'{0}\' added to list'.format(repoAbsolutePath)
            elif os.path.isfile(repoAbsolutePath):
                repoFolderAbsolutePathList.append(repoAbsolutePath)
                if self.verbosity > 0:
                    print '- repository package file \'{0}\' added to list'.format(repoAbsolutePath)
            else:
                CommonApplication.reportError('path \'{0}\' does not exist, ignored'.format(repoAbsolutePath))

        RepositoryFolder.setList(None)
        return (configTreesList, repoFolderAbsolutePathList)
    
    
    def parseFolderRecursive(self, parent, folderAbsolutePath, parsedFolders):
        
        crtParent = parent
        localList = []
        for path in self.defaultScripts:
            tentativeFileAbsolutePath = os.path.join(folderAbsolutePath, path)
            if os.path.isfile(tentativeFileAbsolutePath):
                if self.verbosity > 2:
                    print 'is package'
                
                (tentativeFolderAbsolutePath, _) = os.path.split(tentativeFileAbsolutePath)
                if tentativeFolderAbsolutePath not in parsedFolders:
                    packageLocation = PackageLocation(folderAbsolutePath, tentativeFileAbsolutePath)
                    localList = self.parseScript(parent, tentativeFileAbsolutePath, packageLocation)
                    if len(localList) > 0:
                        crtParent = localList[0]
                    parsedFolders.append(tentativeFolderAbsolutePath)
                break
                 
        for name in os.listdir(folderAbsolutePath):
            absolutePath = os.path.join(folderAbsolutePath, name)
            if os.path.isdir(absolutePath):
                if self.verbosity > 2:
                    print 'subfolder {0}'.format(absolutePath)
                self.parseFolderRecursive(crtParent, absolutePath, parsedFolders)
        
        return localList
    
    
    def parseScript(self, parent, scriptAbsolutePath, packageLocation):
        
        if self.verbosity > 0:
            print '- parse file {0}'.format(scriptAbsolutePath)
        
        # list used to collect all objects contributed by encountered 
        # constructors
        localList = []
        Node.setList(localList)
        
        if not os.path.isfile(scriptAbsolutePath):
            raise ErrorWithDescription('Missing script file \'{0}\''.
                                       format(scriptAbsolutePath))
        
        try:
            execfile(scriptAbsolutePath)
        except BaseException as err:
            raise ErrorWithDescription('\'{0}\' in file \'{1}\''.format(err, scriptAbsolutePath))
        
        # compute latest updated file
        tmtime = os.path.getmtime(scriptAbsolutePath)
        if tmtime > CommonApplication.maxScriptUpdateTime:
            CommonApplication.maxScriptUpdateTime = tmtime
        
        # ---------------------------------------------------------------------        
        self.warnNonParsedKeywords(localList)
        
        # manual links to children or to parent
        localList = self.linkChildrenNodes(localList)
        localList = self.linkNodesWithParent(localList)
        
        # process parsed nodes
        for obj in localList:            
            self.processNode(obj, parent, scriptAbsolutePath, packageLocation)
            
        # return the current list, useful for the root node,
        # all other use the parent to build the tree                    
        return localList


    def warnNonParsedKeywords(self, localList):

        for node in localList:            

            # warn if some of the keywords were not parsed
            if len(node.getNonRecognisedKeywords()) > 0:
                print 'Ignored keywords {0} in {1}'.format(
                        node.getNonRecognisedKeywords(), node.getId())
        
        return
        

    def linkChildrenNodes(self, localList):
                
        for node in localList:
            
            if node.getChildrenList() == None:
                continue
                
            # print 'has children {0}'.format(node.getId())
            for child in node.getChildrenList():
                # print 'child {0}'.format(child.getId())
                
                # link-up to parent
                child.setTreeParent(node)
                # link-down to child
                node.addTreeChild(child)
            
        shortList = []
        for node in localList:
            
            # non-linked nodes will be processed further
            if node.getTreeParent() == None:
                shortList.append(node)
                        
        return shortList
    

    def linkNodesWithParent(self, localList):
        
        oldList = localList
        while True:
            
            newList = []
            
            for node in oldList:
                
                parentName = node.getParentId()
                if parentName == None:
                    newList.append(node)
                    continue
                
                # this node has a parent definition
                
                found = False
                for parentNode in oldList:                    
                    if parentName == parentNode.getId():
                        found = True
                        break
                    
                # if it's parent is not know, continue                
                if not found:
                    newList.append(node)
                    continue                    
                
                # if the node parent is known, link to it
                node.setTreeParent(parentNode)
                parentNode.addTreeChild(node)
                # do not pass it to new list
            
            if len(oldList) == len(newList):
                break
            
            oldList = newList
            
        return newList
    
    
    def processNode(self, node, parent, scriptAbsolutePath, packageLocation):
        
        # check if the id was already used
        if  CommonApplication.isObjectById(node.getId()):
                
            oldObject = CommonApplication.getObjectById(node.getId())
            oldName = oldObject.getName()
            oldDescription = oldObject.getDescription()
            
            if (oldName == node.getName()) and (oldDescription == node.getDescription()):
                return
            
            raise ErrorWithDescription('Id \'{0}\' \'{1}\' redefined (was \'{2}\')'.
                            format(node.getId(), node.getName(), oldName))

        nodeName = node.getName()
        # check if the name was already used
        if  CommonApplication.isObjectByName(nodeName):
                
            oldObject = CommonApplication.getObjectByName(nodeName)
            oldId = oldObject.getId()
            oldDescription = oldObject.getDescription()
            
            if (oldId == node.getId()) and (oldDescription == node.getDescription()):
                return
            
            raise ErrorWithDescription('Name \'{0}\' \'{1}\' redefined (was \'{2}\')'.
                            format(nodeName, node.getId(), oldId))
              
        if node.getObjectType() == 'Configuration':
            if  CommonApplication.isConfigurationByName(nodeName):
                oldObject = CommonApplication.getConfigurationByName(nodeName)
                oldId = oldObject.getId()
                raise ErrorWithDescription('Name \'{0}\' \'{1}\' redefined (was \'{2}\')'.
                            format(nodeName, node.getId(), oldId))
            
                
        # eventually process local parent
        parentNodeId = node.getParentId()
        if parentNodeId != None and parent != None:
            if parent.getId() != parentNodeId:
                print 'Parent of {0} already is {1}, redefined as {2}, ignored'.format(
                                node.getId(), parent.getId(), parentNodeId)
            parentNodeId = None
            
        if parentNodeId != None:
            
            # compute parent object from parent name
            if  not CommonApplication.isObjectById(parentNodeId):
                # TODO: check if possible to use a deferred list
                raise ErrorWithDescription('Parent {0} not defined'.
                                               format(parentNodeId))
                    
            crtParent = CommonApplication.getObjectById(parentNodeId)
        else:
            crtParent = parent

        if node.getTreeParent() == None:
            
            # up-link from the current object to the given parent
            node.setTreeParent(crtParent)
            
            # down-link from the parent to the current object
            if crtParent != None:
                crtParent.addTreeChild(node)

        # remember the current package location
        if node.getPackageLocation() == None:
            node.setPackageLocation(packageLocation)
                        
        # store current object in the global dictionary    
        CommonApplication.insertObject(node)

        # remember the current script path
        node.setScriptAbsolutePath(scriptAbsolutePath)
        
        if node.getObjectType() == 'Configuration':
            # store current configuration in the global dictionary    
            CommonApplication.insertConfigurationByName(node)

        # check copyFiles 
        copyFilesList = node.getCopyFilesList()
        if copyFilesList != None:
            
            for copyFile in copyFilesList:                
                if len(copyFile) >= 2:
                    srcConfigFileName = copyFile[0].strip()
                else:
                    raise ErrorWithDescription('Destination missing in \'{0}\', node \'{1}\''.format(copyFile, node.getName()))
                
                (scriptAbsoluteFolderPath, _) = os.path.split(node.getScriptAbsolutePath())
                srcAbsoluteFileName = os.path.join(scriptAbsoluteFolderPath, 
                                                   srcConfigFileName)
                
                if not os.path.isfile(srcAbsoluteFileName):
                    raise ErrorWithDescription('copy source {0} not a file in node \'{1}\''.format(srcConfigFileName, node.getName()))
                
                # compute latest updated file
                tmtime = os.path.getmtime(srcAbsoluteFileName)
                if tmtime > CommonApplication.maxScriptUpdateTime:
                    CommonApplication.maxScriptUpdateTime = tmtime
                   
        # process inner scripts        
        scriptsList = node.getIncludesList()
        if scriptsList != None:
                
            (baseAbsolutePath, _) = os.path.split(scriptAbsolutePath)
                                
            for child in scriptsList:
                    
                # print child
                childAbsolutePath = os.path.abspath(os.path.join(
                                                baseAbsolutePath, child))
                # print childAbsolutePath
                    
                self.parseScript(node, childAbsolutePath, packageLocation)
                
        
        # process children nodes recursively
        # children were moved to tree by linkChildrenNodes()
        childrenList = node.getTreeChildrenList()
        if childrenList != None:
            
            for child in childrenList:
                self.processNode(child, node, scriptAbsolutePath, packageLocation)

        return
    
    
    def dumpTree(self, repositoriesList, isLoaded):
        
        if not isLoaded:
            print "The repositories full trees:"
        else:
            print "The loaded repositories nodes:"
        
        print
        for tree in repositoriesList:
            self.dumpTreeRecursive(tree, 0, isLoaded)
        return
    
        
    def dumpTreeRecursive(self, node, depth, isLoaded):
        
        if isLoaded and (not node.isLoaded()):
            return
        
        indent = '   '
        objectType = node.getObjectType()
        
        kind = ' ({0}'.format(objectType)
        if node.getCategory() != None:
            kind += ',{0}'.format(node.getCategory())
        if node.getValueType() != None:
            kind += ',{0}'.format(node.getValueType())
        kind += ')'
        
        if objectType not in ['Toolchain', 'Configuration']:
            kind += (' +E' if node.isEnabled() else ' -E')
            kind += (' +A' if node.isActive() else ' -A')
        
        print '{0}* {1} \'{2}\'{3}'.format(indent * depth, node.getId(),
                            node.getName(), kind)

        if objectType in ['Toolchain']:

            toolsDict = node.getToolsDict()
            for key in toolsDict:
                tool = toolsDict[key]
                print '{0}- tool {1} \'{2}\' '.format(indent * (depth + 1), key, tool.getDescription())
            
            compilerPreprocessorOptions = node.getProperty('compilerPreprocessorOptions')
            if compilerPreprocessorOptions != None:
                print '{0}- compilerPreprocessorOptions \'{1}\' '.format(indent * (depth + 1), compilerPreprocessorOptions)

            compilerOptimisationOptions = node.getProperty('compilerOptimisationOptions')
            if compilerOptimisationOptions != None:
                print '{0}- compilerOptimisationOptions \'{1}\' '.format(indent * (depth + 1), compilerOptimisationOptions)
                 
            compilerMiscOptions = node.getProperty('compilerMiscOptions')
            if compilerMiscOptions != None:
                print '{0}- compilerMiscOptions \'{1}\' '.format(indent * (depth + 1), compilerMiscOptions)

        elif objectType in ['Configuration']:
            packageLocation = node.getPackageLocation()
            if packageLocation != None:
                print '{0}- packageFolder \'{1}\''.format(indent * (depth + 1),
                                        packageLocation.getFolderAbsolutePath())
                
            buildConfigurationName = node.getBuildConfigurationName()
            if buildConfigurationName != None:
                print'{0}- buildConfigurationName=\'{1}\''.format(indent * (depth + 1), buildConfigurationName)
                
            optionsList = node.getOptionsList()
            if optionsList != None and len(optionsList) > 0:
                for key in optionsList.keys():
                    print'{0}- option {1}={2}'.format(indent * (depth + 1), key,
                                                      optionsList[key])
                         
            buildFolder = node.getBuildFolder()
            if buildFolder != None:
                print'{0}- buildFolder=\'{1}\''.format(indent * (depth + 1), buildFolder)
    
            preprocessorSymbols = node.getPreprocessorSymbolsList()
            if preprocessorSymbols != None:
                for preprocessorSymbol in preprocessorSymbols:
                    print '{0}- preprocessorSymbol=\'{1}\''.format(indent * (depth + 1),
                                                                preprocessorSymbol)
                        
            toolchainId = node.getToolchainId()
            if toolchainId != None:
                print'{0}- toolchain=\'{1}\''.format(indent * (depth + 1), toolchainId)
        
        else:
            # all othe common nodes
            packageLocation = node.getPackageLocation()
            if packageLocation != None:
                print '{0}- packageFolder \'{1}\''.format(indent * (depth + 1),
                                        packageLocation.getFolderAbsolutePath())
                
            # dump sources, if any
            sourcesList = node.getSourceFilesList()
            if sourcesList != None:
                for source in sourcesList:
                    print '{0}- sourceFile {1}'.format(indent * (depth + 1), source)
    
            # dump loadPackages, if any
            loadPackagesList = node.getLoadPackagesList()
            if loadPackagesList != None:
                for loadPackages in loadPackagesList:
                    print '{0}- loadPackage {1}'.format(indent * (depth + 1), loadPackages)
                    
            headerDefinition = node.getHeaderDefinition()
            if headerDefinition != None:
                print '{0}- headerDefinition {1}'.format(indent * (depth + 1), headerDefinition)
                   
            headerPath = node.getHeaderFile()
            if headerPath != None:
                print '{0}- headerFile \'{1}\''.format(indent * (depth + 1), headerPath)
        
        try:
            requirementsList = node.getRequiresList()
            if requirementsList != None:
                for requirement in requirementsList:
                    print '{0}- requirement \'{1}\''.format(indent * (depth + 1), requirement)
        except:
            pass 
                
        children = node.getTreeChildrenList()
        if children == None:
            return
        
        # iterate through all children
        for child in children:           
            self.dumpTreeRecursive(child, depth + 1, isLoaded)            
            
        return

    
    def dumpConfiguration(self, configTreesList):
        
        print "The configuration trees:"
        print
        for tree in configTreesList:
            self.dumpConfigurationRecursive(tree, 0)
        return
    
        
    def dumpConfigurationRecursive(self, node, depth):
        
        indent = self.indent
        kind = ' ({0})'.format(node.getObjectType())
            
        print '{0}* {1} \'{2}\'{3}'.format(indent * depth, node.getId(),
                            node.getName(), kind)

        # dump loadPackages, if any
        loadPackagesList = node.getLoadPackagesList()
        if loadPackagesList != None:
            for loadPackages in loadPackagesList:
                print '{0}- loadPackages {1}'.format(indent * (depth + 1), loadPackages)
        
        optionsList = node.getOptionsList()
        if optionsList != None and len(optionsList) > 0:
            for key in optionsList.keys():
                print'{0}- option {1}={2}'.format(indent * (depth + 1), key,
                                                  optionsList[key])
                     
        buildFolder = node.getBuildFolder()
        if buildFolder != None:
            print'{0}- buildFolder=\'{1}\''.format(indent * (depth + 1), buildFolder)

        preprocessorSymbols = node.getPreprocessorSymbolsList()
        if preprocessorSymbols != None:
            for preprocessorSymbol in preprocessorSymbols:
                print '{0}- preprocessorSymbol=\'{1}\''.format(indent * (depth + 1),
                                                            preprocessorSymbol)
                    
        toolchainId = node.getToolchainId()
        if toolchainId != None:
            print'{0}- toolchain=\'{1}\''.format(indent * (depth + 1), toolchainId)
            
        children = node.getTreeChildrenList()
        if children == None:
            return
        
        # iterate through all children
        for child in children:           
            self.dumpConfigurationRecursive(child, depth + 1)
                        
        return


    def getBuildConfigurationNode(self, configName):

        if not CommonApplication.isConfigurationByName(configName):
            raise ErrorWithDescription('Missing configuration name=\'{0}\', cancelled'.format(configName))
        
        configNode = CommonApplication.getConfigurationByName(configName)
        return configNode
    
    
    def loadBuildConfiguration(self, configNode, minVerbosity):
        
        if self.verbosity > minVerbosity:
            print 'Load configuration node \'{0}\'...'.format(configNode.getName())
        
        self.loadConfigNode(configNode, 0)

        return configNode

    
    def loadConfiguration(self, configTreesList, sid, minVerbosity):
        
        if not CommonApplication.isObjectById(sid):
            raise ErrorWithDescription('Missing configuration node id=\'{0}\', cancelled'.format(sid))
        
        configNode = CommonApplication.getObjectById(sid)
        if self.verbosity > minVerbosity:
            print 'Load configuration node \'{0}\'...'.format(configNode.getName())
        
        self.loadConfigNode(configNode, 0)
        # updated = self.loadConfigNode(configNode, 0)
        # print '- {0} nodes loaded'.format(updated)

        return configNode
    
    
    def loadConfigNode(self, configNode, depth):
        
        if configNode.getObjectType() != 'Configuration':
            raise ErrorWithDescription('Not a configuration node {0}'.format(configNode.getName()))
        
        indent = self.indent
        if self.verbosity > 1:
            print '{0}process {1}'.format(indent * depth, configNode.getId())

        updated = 0
        loadList = configNode.getLoadPackagesList()
        if loadList != None:
            for load in loadList:
                updated += self.loadPackageTreeNode(load, depth + 1)
        
        treeParent = configNode.getTreeParent()
        if treeParent != None:
            if treeParent.getObjectType() != 'Configuration':
                updated += self.loadPackageTreeNode(treeParent.getId(), depth + 1)
            else:
                updated += self.loadConfigNode(treeParent, depth + 1)
               
        return updated
    
                
    def loadPackageTreeNode(self, treeNodeId, depth):

        if  not  CommonApplication.isObjectById(treeNodeId):
            raise ErrorWithDescription('Missing node to load {0}'.format(treeNodeId))
        
        indent = self.indent

        treeNode = CommonApplication.getObjectById(treeNodeId)
        if treeNode.getObjectType() == 'Configuration':
            updated = self.loadConfigNode(treeNode, depth + 1)
            return updated
        
        treePackageNode = treeNode.getPackageTreeNode()
        if treePackageNode == None:
            updated = 0
            return updated
        
        if self.verbosity == 1:
            print '- package \'{0}\' and parents loaded'.format(treePackageNode.getName())
        elif self.verbosity > 1:
            print '{0}load {1}'.format(indent * depth, treeNodeId)
            
        updated = treePackageNode.setIsLoadedRecursive()
        
        loadPackagesList = treePackageNode.getLoadPackagesList()
        if loadPackagesList != None:
            for loadPackages in loadPackagesList:
                updated += self.loadPackageTreeNode(loadPackages, depth + 1)
                        
        return updated
    
    
    def dumpPreprocessorDefinitions(self, repositoriesList):
        
        print "The preprocessor definitions:"
        
        headersDict = self.buildHeadersDict(repositoriesList)
        for key in headersDict.iterkeys():
            headerLines = headersDict[key]
            print
            print key
            for headerLine in headerLines:
                print headerLine
            
        return
    

    def buildHeadersDict(self, repositoriesList):
        
        headersDict = {}
        for tree in repositoriesList:
            self.buildHeadersDictRecursive(tree, 0, headersDict)
            
        return headersDict

    
    def buildHeadersDictRecursive(self, node, depth, headersDict):

        if not node.isLoaded():
            return
        
        headerLineAndFileName = node.getHeaderLineAndFileName()
        if headerLineAndFileName != None:
            
            (headerDefinition, headerFile) = headerLineAndFileName
            
            if self.verbosity > 1:
                print 'process {0}'.format(node.getId())

                print 'file: \'{0}\''.format(headerFile)
                print headerDefinition
                print
             
            if headerFile not in headersDict:
                headersDict[headerFile] = []
                 
            headersDict[headerFile].append(headerDefinition)
            
        children = node.getTreeChildrenList()
        if children == None:
            return
        
        # iterate through all children
        for child in children:           
            self.buildHeadersDictRecursive(child, depth + 1, headersDict)            
        
        return
    
    
    def dumpSourceFiles(self, repositoriesList):
        
        print "The source files to compile:"
        
        sourcesDict = self.buildSourcesDict(repositoriesList)
        for key in sourcesDict.iterkeys():
            sources = sourcesDict[key]
            print
            print key
            for source in sources:
                print '   source {0}, from node \'{1}\''.format(source['fileName'], source['repoNode'].getName())
            
        return
    

    def buildSourcesDict(self, repositoriesList):

        sourcesDict = {}
        for tree in repositoriesList:
            self.buildSourcesDictRecursive(tree, 0, sourcesDict)
            
        return sourcesDict

    
    def buildSourcesDictRecursive(self, node, depth, sourcesDict):
        
        if not node.isLoaded():
            return
        
        if node.isActive():
            
            sourceFiles = node.getSourceFilesList()
            if sourceFiles != None:
            
                if self.verbosity > 1:
                    print 'process {0}'.format(node.getId())

                packageFolder = node.getPackageLocation().getFolderAbsolutePath()
                # if self.verbosity:
                #    print 'package folder: \'{0}\''.format(packageFolder)

                treeRoot = node.getTreeRoot()
                buildSubFolder = treeRoot.getBuildSubFolderWithDefault()
                # if self.verbosity:
                #    print 'build subfolder: \'{0}\''.format(buildSubFolder)
                
                rootPackageFolder = treeRoot.getPackageLocation().getFolderAbsolutePath()
                # if self.verbosity:
                #    print 'root package folder: \'{0}\''.format(rootPackageFolder)
                
                sourcesPathsList = node.getSourcePathsListRecursive()
                if sourcesPathsList == None:
                    sourcesPathsList = CommonApplication.getSourcePathsListDefault()
                
                      
                for sourceFile in sourceFiles:
                    if self.verbosity > 1:
                        print 'source file: \'{0}\''.format(sourceFile)

                    foundSourcePath = None
                    for sourcePath in sourcesPathsList:
                        sourceAbsolutePath = os.path.join(packageFolder, sourcePath, sourceFile)
                        if os.path.isfile(sourceAbsolutePath):
                            if self.verbosity > 1:
                                print 'source file path: \'{0}\''.format(sourceAbsolutePath)
                            foundSourcePath = sourcePath
                            break
                        
                    if foundSourcePath == None:
                        CommonApplication.reportError('source file: \'{0}\' not found'.format(sourceFile))
                        continue
                    
                    if not sourceAbsolutePath.startswith(rootPackageFolder):
                        CommonApplication.reportError('paths do not match')
                        continue
                    
                    subPath = sourceAbsolutePath[len(rootPackageFolder) + 1:]
                    # print subPath
                    subPathList = subPath.split(os.sep)
                    # print subPathList
                    
                    buildPathList = []
                    buildPathList.append(buildSubFolder)
                    buildPathList.extend(subPathList[:-1])
                    
                    buildPathString = os.sep.join(buildPathList)
                    if self.verbosity > 1:
                        print 'build path: {0}'.format(buildPathString)
                    
                    if buildPathString not in sourcesDict:
                        # add an empty list for this build path
                        sourcesDict[buildPathString] = []
                    
                    crtSourceDict = {}
                    crtSourceDict['fileName'] = sourceFile
                    crtSourceDict['buildPathList'] = buildPathList
                    crtSourceDict['sourceAbsolutePath'] = sourceAbsolutePath
                    crtSourceDict['repoNode'] = node
                    
                    # append the current source file to the path
                    sourcesDict[buildPathString].append(crtSourceDict)
                if self.verbosity > 1:
                    print
             
        children = node.getTreeChildrenList()
        if children == None:
            return
        
        # iterate through all children
        for child in children:           
            self.buildSourcesDictRecursive(child, depth + 1, sourcesDict)            
        
        return
    
    
    def processInitialIsEnabled(self, repositoriesList):
    
        while True:
            count = 0
            for tree in repositoriesList:
                count += self.processInitialIsEnabledRecursive(tree, 0)
                            
            if count == 0:
                break
            
        return


    def processInitialIsEnabledRecursive(self, node, depth):

        count = 0
        initialIsEnabled = node.getInitialIsEnabled()
        if initialIsEnabled != None:
            if not isinstance(initialIsEnabled, bool):
                # boolean values were already processed in constructor
                try:
                    evaluatedValue = eval(initialIsEnabled)
                except:
                    evaluatedValue = True if initialIsEnabled else False
                
                count += node.setIsEnabledWithCount(evaluatedValue)
                    
                if count > 0 and self.verbosity > 0:
                    status = 'enabled' if evaluatedValue else 'disabled'
                    print '- {0} \'{1}\' initially {2}'.format(
                        node.getObjectType().lower(), node.getName(), status)
            
        children = node.getTreeChildrenList()
        if children == None:
            return count
    
        # iterate through all children
        for child in children:           
            count += self.processInitialIsEnabledRecursive(child, depth + 1)            

        return count


    def processRequiresProperties(self, repositoriesList, configNode, doReport):
    
        step = 0
        while True:
            step += 1
            if self.verbosity > 1:
                print 'step {0}'.format(step)

            clearGlobalCount()
            
            # first process the configuration requirements
            self.processConfigRequiresRecursive(configNode, 0, doReport)
            
            # than the packages trees
            for tree in repositoriesList:
                self.processTreeRequiresRecursive(tree, 0, doReport)
                self.processImplementsPropertiesRecursive(tree, 0)
                            
            if getGlobalCount() == 0:
                break
            
        return


    def processTreeRequiresRecursive(self, node, depth, doReport):

        if self.verbosity > 1:
            print 'process {0}'.format(node.getId())

        if not node.isLoaded():
            if self.verbosity > 1:
                print 'not loaded'
            return

        if  node.isEnabled():
            requiresList = node.getRequiresList()
            if requiresList != None:
                
                for requires in requiresList:
                    if not eval(requires):
                        # count errors
                        CommonApplication.addToErrorCount(1)
                        if doReport:
                            CommonApplication.reportError('Requirement \'{0}\' not satisfied for node \'{1}\' ({2})'.
                                   format(requires, node.getName(), node.getId()))
        
        else:
            if self.verbosity > 1:
                print 'not enabled'
            
        children = node.getTreeChildrenList()
        if children == None:
            return 
    
        # iterate through all children
        for child in children:           
            self.processTreeRequiresRecursive(child, depth + 1, doReport)            

        return


    def processConfigRequiresRecursive(self, node, depth, doReport):

        if self.verbosity > 1:
            print 'process {0}'.format(node.getId())
            
        requiresList = node.getRequiresList()
        if requiresList != None:
            
            for requires in requiresList:
                if not eval(requires):
                    if doReport:
                        CommonApplication.reportError('Requirement \'{0}\' not satisfied for node \'{1}\''.
                               format(requires, node.getName()))

        parentNode = node.getTreeParent()
        if parentNode == None:
            return
        
        return self.processConfigRequiresRecursive(parentNode, depth + 1, doReport)



    def processImplementsPropertiesRecursive(self, node, depth):

        if not node.isLoaded():
            return

        if not node.isEnabled():
            return
        
        implementsList = node.getImplementsList()
        if implementsList != None:
            
            for sid in implementsList:
                if not CommonApplication.isObjectById(sid):
                    CommonApplication.reportError('Missing id=\'{0}\', \'implements\' property ignored'.format(sid))
                    
                interfaceNode = CommonApplication.getObjectById(sid)
                if interfaceNode.getObjectType() != 'Interface':
                    CommonApplication.reportError('Node id=\'{0}\', not an interface, \'implements\' property ignored'.format(sid))
                
                # finally add the current node to the interface implementations list    
                count = interfaceNode.addImplementationWithCount(node.getId())
                if count > 0:
                    if self.verbosity > 0:
                        print '- {0} \'{1}\' implements \'{2}\''.format(
                                    node.getObjectType().lower(), node.getName(),
                                    interfaceNode.getName())
                    addToGlobalCount(count)
                           
        children = node.getTreeChildrenList()
        if children == None:
            return 
    
        # iterate through all children
        for child in children:           
            self.processImplementsPropertiesRecursive(child, depth + 1)            

        return


    def processSymbolsDict(self, repositoriesList):
    
        count = 0
        for tree in repositoriesList:
            count += self.processSymbolsDictRecursive(tree, 0)
            
        return count


    def processSymbolsDictRecursive(self, node, depth):

        count = 0
        
        if not node.isLoaded():
            return count

        headerDefinition = node.getHeaderDefinition()
        if headerDefinition != None:

            if CommonApplication.isObjectBySymbol(headerDefinition):
                firstDefinition = CommonApplication.getObjectBySymbol(headerDefinition)
                CommonApplication.reportError('Preprocessor symbol {0} redefined in \'{1}\' (first definition in {2})'.format(headerDefinition, node.getName(), firstDefinition.getName()))
            else:
                CommonApplication.insertObjectBySymbol(node)
                count += 1
                
        children = node.getTreeChildrenList()
        if children == None:
            return count
    
        # iterate through all children
        for child in children:           
            count += self.processSymbolsDictRecursive(child, depth + 1)            

        return count



    def validateToolchain(self, configNode):
        
        toolchainId = None
        toolchainNode = None
        
        if self.toolchainId != None:
            toolchainId = self.toolchainId
            if CommonApplication.isObjectById(toolchainId):
                toolchainNode = CommonApplication.getObjectById(toolchainId)
            else:
                CommonApplication.reportError('param toolchain \'{0}\' not found, ignored'.format(toolchainId))
                toolchainId = None

        if toolchainId == None:           
            toolchainId = configNode.getToolchainId()
            
            if toolchainId != None and CommonApplication.isObjectById(toolchainId):
                toolchainNode = CommonApplication.getObjectById(toolchainId)
            else:
                CommonApplication.reportError('config toolchain \'{0}\' not found, ignored'.format(toolchainId))
                toolchainId = None
            
        if toolchainNode == None:
            raise ErrorWithDescription('Mandatory toolchain definition missing, quitting')

        return (toolchainNode, toolchainId)


    def generatePreprocessorDefinitions(self, repositoriesList, outputFolder, outputSubFolder):
        
        headersDict = self.buildHeadersDict(repositoriesList)
        for fileRelativePath in headersDict.iterkeys():
            
            fileAbsolutePath = os.path.abspath(os.path.join(outputFolder, outputSubFolder, fileRelativePath))
            if self.verbosity > 1:
                print fileAbsolutePath

            (folderAbsolutePath, _) = os.path.split(fileAbsolutePath)
            if not os.path.isdir(folderAbsolutePath):
                if self.verbosity > 1:
                    print('Create folder \'{0}\''.format(folderAbsolutePath))
                os.makedirs(folderAbsolutePath)
            
            if self.verbosity > 0:
                if not os.path.isfile(fileAbsolutePath):
                    print('Write file \'{0}\''.format(fileAbsolutePath))
                else:
                    print('Overwrite file \'{0}\''.format(fileAbsolutePath))

            # truncate existing files
            textFile = open(fileAbsolutePath, 'w')
            
            doNotEditMessage = CommonApplication.getDoNotEditMessage()
            
            textFile.write('//{0}//\n'.format('/' * (len(doNotEditMessage) + 2)))
            textFile.write('// {0} //\n'.format(doNotEditMessage))
            textFile.write('//{0}//\n'.format('/' * (len(doNotEditMessage) + 2)))
            textFile.write('\n')
            
            headerLines = headersDict[fileRelativePath]
            for headerLine in headerLines:
                if self.verbosity > 0:
                    print '- {0}'.format(headerLine)
                textFile.write(headerLine)
                textFile.write('\n')
                
            textFile.close()

        if self.verbosity > 1:
            print
            
        return


    def getRepositoriesListActiveNodesGenerator(self, repositoriesList):
        
        for tree in repositoriesList:
            for node in self.getRepositoryActiveNodesGeneratorRecursive(tree, 0):
                yield node

    # iterate the current node and then all children nodes
    def getRepositoryActiveNodesGeneratorRecursive(self, node, depth):
        
        if not node.isEnabled():
            return
        
        if node.isActive():
            yield node
        
        children = node.getTreeChildrenList()
        if children == None:
            return
        
        # iterate through all children
        for child in children:           
            for node in self.getRepositoryActiveNodesGeneratorRecursive(child, depth + 1):
                yield node           
    
        return
    

    def copyCustomFiles(self, repositoriesList, configNode, outputFolder, outputSubFolder):

        # iterate all nodes, including the Configuration nodes
        for node in self.getRepositoriesListActiveNodesGenerator(repositoriesList):
            if self.verbosity > 1:
                print 'process {0}'.format(node.getName())
            
            copyFilesList = node.getCopyFilesList()
            self.processCopyFilesList(copyFilesList, node, outputFolder, outputSubFolder)
                    
        return
    
    
    def processCopyFilesList(self, copyFilesList, node, outputFolder, outputSubFolder):

        if copyFilesList != None and len(copyFilesList) > 0:
            if self.verbosity > 1:
                print 'copyFilesList {0}'.format(copyFilesList)
                
            for copyFile in copyFilesList:
                srcConfigFileName = copyFile[0].strip()
                dstConfigFileName = copyFile[1].strip()
                                        
                (scriptAbsoluteFolderPath, _) = os.path.split(
                                    node.getScriptAbsolutePath())
                srcAbsoluteFileName = os.path.join(scriptAbsoluteFolderPath, 
                                                   srcConfigFileName)

                dstAbsoluteFilePath = os.path.abspath(os.path.join(
                            outputFolder, outputSubFolder, dstConfigFileName))

                (_, dstFileName) = os.path.split(dstConfigFileName)
                if len(dstFileName) == 0:
                    dstAbsoluteFolderPath = dstAbsoluteFilePath
                    (_,dstAbsoluteFileName) = os.path.split(srcAbsoluteFileName)
                    dstAbsoluteFilePath = os.path.join(dstAbsoluteFilePath, dstAbsoluteFileName)
                else:
                    (dstAbsoluteFolderPath, _) = os.path.split(dstAbsoluteFilePath)
                    
                if not os.path.isdir(dstAbsoluteFolderPath):
                    if self.verbosity > 1:
                        print('Create folder \'{0}\''.format(dstAbsoluteFolderPath))
                    os.makedirs(dstAbsoluteFolderPath)
                                    
                if self.verbosity > 1:
                    print('Copy file \'{0}\' to \'{1}\''.format(
                                srcAbsoluteFileName, dstAbsoluteFilePath))
                
                shutil.copyfile(srcAbsoluteFileName, dstAbsoluteFilePath)
                
        return
        
        
    def generateAllMakeFiles(self, repositoriesList, configNode, toolchainNode, 
                             outputFolder, outputSubFolder):

        artefactName = configNode.getArtefactNameRecursive()
        if artefactName == None:
            raise ErrorWithDescription('Missing artefactName in configuration')
                
        # build a dictionary of sources, grouped by folder relative path
        sourcesDict = self.buildSourcesDict(repositoriesList)
        
        # iterate all folders
        for folderRelativePath in sourcesDict.iterkeys():
            
            folderAbsolutePath = os.path.abspath(os.path.join(outputFolder, 
                                    outputSubFolder, folderRelativePath))
            if not os.path.isdir(folderAbsolutePath):
                if self.verbosity > 1:
                    print('Create folder \'{0}\''.format(folderAbsolutePath))
                os.makedirs(folderAbsolutePath)
            
            self.generateSubdirMk(sourcesDict, folderAbsolutePath, 
                                  folderRelativePath, configNode, toolchainNode, 
                                  outputFolder, outputSubFolder)
        
        count = CommonApplication.getErrorCount()
        if count == 0:
            self.generateRootMakeFiles(sourcesDict, toolchainNode, configNode, 
                                       outputFolder, outputSubFolder)
            
        return

    
    def generateSubdirMk(self, sourcesDict, folderAbsolutePath, 
                         folderRelativePath, configNode, toolchainNode, 
                         outputFolder, outputSubFolder):
        
        subdirAbsolutePath = os.path.join(folderAbsolutePath, 'subdir.mk')
        
        if self.verbosity > 0:
            if not os.path.isfile(subdirAbsolutePath):
                print('Write file \'{0}\''.format(subdirAbsolutePath))
            else:
                print('Overwrite file \'{0}\''.format(subdirAbsolutePath))

        f = open(subdirAbsolutePath, 'w')
        
        self.generateDoNotEditMessage(f)
        
        sources = sourcesDict[folderRelativePath]
        
        cppList = self.groupSourceFilesByType(sources, ['.cpp'])
        cList = self.groupSourceFilesByType(sources, ['.c'])
        sList = self.groupSourceFilesByType(sources, ['.S'])
                
        allList = []
        allList.extend(cppList)
        allList.extend(cList)
        allList.extend(sList)
        
        buildTargetCpuOptions = configNode.getBuildTargetCpuOptionsRecursive()
        
        makeObjectsVariable = toolchainNode.getPropertyRecursiveWithDefault('makeObjectsVariable')
 
        compilerObjectsExtension = toolchainNode.getPropertyRecursiveWithDefault('compilerObjectsExtension')
            
        if len(allList) > 0:
            f.write('# Each subdirectory must supply rules for building sources it contributes\n')
            f.write('\n')
            f.write('# For each source add to the build variables all inputs and outputs that these tools contribute\n')
            f.write('\n')
               
            for source in allList:
                fileNameComplete = source['fileName']
                (fileName, _) = os.path.splitext(fileNameComplete)
                
                p = os.path.join(folderRelativePath, '{0}.{1}'.format(fileName, 
                                                    compilerObjectsExtension))
                sourceAbsolutePath = source['sourceAbsolutePath']
                
                toolStandard = None;
                toolOptions = None;
                                   
                fType = source['type']
                if fType == '.cpp':
                    typeDeps = 'CPP_DEPS'
                    typeSrcs = 'CPP_SRCS'
                    tool = toolchainNode.getToolRecursive('cpp')
                    if tool == None:
                        print 'WARN: Missing \'cpp\' tool in toolchain \'{0}\', using defaults'.format(toolchainNode.getName())                      
                        toolName = 'g++'
                        toolDesc = 'GNU default g++'
                    else:
                        toolName = toolchainNode.getToolProgramNameRecursiveWithSubstitutions('cpp')
                        if toolName == None:
                            print 'WARN: Missing \'programName\' in tool \'cpp\', toolchain \'{0}\', using default \'g++\''.format(toolchainNode.getName())                      
                            toolName = 'g++'
                        toolDesc = toolchainNode.getToolDescriptionRecursive('cpp')
                        if toolDesc == None:
                            print 'WARN: Missing \'description\' in tool \'cpp\', toolchain \'{0}\', using default \'GNU default g++\''.format(toolchainNode.getName())                      
                            toolDesc = 'GNU default g++'
                        toolStandard = toolchainNode.getToolStandardRecursive('cpp')
                        toolOptions = toolchainNode.getToolOptionsRecursive('cpp')
                        
                elif fType == '.c':
                    typeDeps = 'C_DEPS'
                    typeSrcs = 'C_SRCS'
                    tool = toolchainNode.getToolRecursive('cc')
                    if tool == None:                        
                        print 'WARN: Missing \'cc\' tool in toolchain \'{0}\', using defaults'.format(toolchainNode.getName())                      
                        toolName = 'gcc'
                        toolDesc = 'GNU default gcc'
                    else:
                        toolName = toolchainNode.getToolProgramNameRecursiveWithSubstitutions('cc')
                        if toolName == None:
                            print 'WARN: Missing \'programName\' in tool \'cc\', toolchain \'{0}\', using default \'gcc\''.format(toolchainNode.getName())                      
                            toolName = 'gcc'
                        toolDesc = toolchainNode.getToolDescriptionRecursive('cc')
                        if toolDesc == None:
                            print 'WARN: Missing \'description\' in tool \'cc\', toolchain \'{0}\', using default \'GNU default gcc\''.format(toolchainNode.getName())                      
                            toolDesc = 'GNU default gcc'
                        toolStandard = toolchainNode.getToolStandardRecursive('cc')
                        toolOptions = toolchainNode.getToolOptionsRecursive('cc')
                
                elif fType == '.S':
                    typeDeps = 'S_DEPS'
                    typeSrcs = 'S_SRCS'
                    tool = toolchainNode.getToolRecursive('asm')
                    if tool == None:                        
                        print 'WARN: Missing \'asm\' tool in toolchain \'{0}\', using defaults'.format(toolchainNode.getName())                      
                        toolName = 'gcc'
                        toolDesc = 'GNU default gcc'
                    else:
                        toolName = toolchainNode.getToolProgramNameRecursiveWithSubstitutions('asm')
                        if toolName == None:
                            print 'WARN: Missing \'programName\' in tool \'asm\', toolchain \'{0}\', using default \'gcc\''.format(toolchainNode.getName())                      
                            toolName = 'gcc'
                        toolDesc = tool.getDescription()
                        if toolDesc == None:
                            print 'WARN: Missing \'description\' in tool \'asm\', toolchain \'{0}\', using default \'GNU default gcc\''.format(toolchainNode.getName())                      
                            toolDesc = 'GNU default gcc'
 
                node = source['repoNode']
                linkPriority = node.getLinkPriority()
               
                objectRelativePath = os.path.join('.', folderRelativePath, '{0}.{1}'.format(fileName, compilerObjectsExtension))                
                prio = ''
                if linkPriority != None:
                    prio = '_{0:02d}'.format(linkPriority)
                
                f.write('{0}{1} += {2}\n'.format(makeObjectsVariable, prio, self.expandPathSpaces(objectRelativePath)))
            
                f.write('{0} += {1}\n'.format(typeSrcs, self.expandPathSpaces(sourceAbsolutePath)))

                depsRelativePath = os.path.join('.', folderRelativePath, '{0}.{1}'.format(fileName, 'd'))
                f.write('{0} += {1}\n'.format(typeDeps, self.expandPathSpaces(depsRelativePath)))

                f.write('\n')

                if self.verbosity > 0:
                    # print '- compile \'{0}\' with \'{1}\''.format(sourceAbsolutePath, toolDesc)
                    eList = source['buildPathList']
                    extra = ''
                    if linkPriority != None:
                        extra += ', linkPriority={0}'.format(linkPriority)
                        
                    ePath = os.path.join(os.sep.join(eList[1:]), fileNameComplete)
                    print '- compile {0} \'{1}\' with \'{2}\'{3}'.format(eList[0], ePath, toolDesc, extra)

                f.write('{0}: {1}\n'.format(self.expandPathSpaces(p), self.expandPathSpaces(sourceAbsolutePath)))
                f.write('\t@echo \'Compiling XCDL file: $<\'\n')

                f.write('\t@echo \'Invoking: {0}\'\n'.format(toolDesc))
                
                f.write('\t{0}'.format(toolName))
                
                preprocessorSymbolsList = configNode.getPreprocessorSymbolsList()
                if preprocessorSymbolsList != None:
                    for preprocessorSymbol in preprocessorSymbolsList:
                        f.write(' -D{0}'.format(preprocessorSymbol))

                compilerPreprocessorOptions = toolchainNode.getPropertyRecursive('compilerPreprocessorOptions')
                f.write(' {0}'.format(compilerPreprocessorOptions))
                                    
                buildFolderAbsolutePath = os.path.abspath(os.path.join(outputFolder, outputSubFolder))
                includeAbsolutePathList = self.computeIncludeAbsolutePathList(source['repoNode'], fileNameComplete, buildFolderAbsolutePath)
                for includeAbsolutePath in includeAbsolutePathList:
                    f.write(' -I"{0}"'.format(includeAbsolutePath))
                
                if buildTargetCpuOptions != None:
                    f.write(' {0}'.format(buildTargetCpuOptions))
                            
                compilerCpu = toolchainNode.getPropertyRecursive('compilerCpu')
                if compilerCpu != None:
                    f.write(' {0}'.format(compilerCpu))

                if toolStandard != None:
                    f.write(' {0}'.format(toolStandard))

                if toolOptions != None:
                    f.write(' {0}'.format(toolOptions))

                compilerOptimisationOptions = toolchainNode.getPropertyRecursive('compilerOptimisationOptions')
                if compilerOptimisationOptions != None:
                    f.write(' {0}'.format(compilerOptimisationOptions))
                
                compilerDebugOptions = toolchainNode.getPropertyRecursive('compilerDebugOptions')
                if compilerDebugOptions != None:
                    f.write(' {0}'.format(compilerDebugOptions))
                    
                compilerWarningOptions = toolchainNode.getPropertyRecursive('compilerWarningOptions')
                if compilerWarningOptions != None:
                    f.write(' {0}'.format(compilerWarningOptions))

                compilerMiscOptions = toolchainNode.getPropertyRecursive('compilerMiscOptions')
                if compilerMiscOptions != None:
                    f.write(' {0}'.format(compilerMiscOptions))
                    
                compilerDepsOptions = toolchainNode.getPropertyRecursive('compilerDepsOptions')
                if compilerDepsOptions != None:
                    f.write(' {0}'.format(compilerDepsOptions))
                    
                compilerOutputOptions = toolchainNode.getPropertyRecursiveWithDefault('compilerOutputOptions')
                f.write(' {0}'.format(compilerOutputOptions))

                compilerInputOptions = toolchainNode.getPropertyRecursiveWithDefault('compilerInputOptions')
                f.write(' {0}'.format(compilerInputOptions))

                f.write('\n')
                
                f.write('\t@echo \'Finished compiling file: $<\'\n')
                f.write('\t@echo \' \'\n')
                f.write('\n')
                                
        f.close()

        return
   
   
    def computeIncludeAbsolutePathList(self, treeNode, fileNameComplete, buildFolderAbsolutePath):
        
        localList = []
        if treeNode == None:
            print 'Internal error: Missing node for source {0}'.format(fileNameComplete)
        else:
            packageTreeNode = treeNode.getPackageTreeNode()
            if packageTreeNode == None:
                print 'Internal error: Missing parent node for source {0}'.format(fileNameComplete)
            else:
                localList2 = packageTreeNode.getBuildIncludeFoldersRecursive()
                
                for path in localList2:
                    if path.find('$(REPO_DIR)') != -1:
                        repoFolder = treeNode.getTreeRoot().getRepositoryFolderAbsolutePath()
                        path = path.replace('$(REPO_DIR)', repoFolder)
                    elif path.find('$(BUILD_DIR)') != -1:
                        path = path.replace('$(BUILD_DIR)', buildFolderAbsolutePath)

                    # add replaced or original path o response list
                    localList.append(path)
                                       
        return localList
        

    def generateDoNotEditMessage(self, builtinFile):
        
        doNotEditMessagee = CommonApplication.getDoNotEditMessage()
        builtinFile.write('#{0}#\n'.format('#' * (len(doNotEditMessagee) + 2)))
        builtinFile.write('# {0} #\n'.format(doNotEditMessagee))
        builtinFile.write('#{0}#\n'.format('#' * (len(doNotEditMessagee) + 2)))
        builtinFile.write('\n')
        
        return
    
    
    def groupSourceFilesByType(self, sources, extList):
        
        resultList = []
        for source in sources:
            fileName = source['fileName']
            (_, fileExt) = os.path.splitext(fileName)

            if fileExt in extList:
                resultList.append(source)
                
                # store current type in dictionary
                if 'type' not in source:
                    source['type'] = extList[0]
                    
        return resultList
    
  
    def expandPathSpaces(self, path):
        
        return path.replace(' ', '\\ ')
      
      
    def getRootMakeFileUpdateTime(self, outputFolder, outputSubFolder):
          
        makefileAbsolutePath = os.path.join(outputFolder, outputSubFolder, 'makefile')
        if not os.path.isfile(makefileAbsolutePath):
            return 0.0
        
        tmtime = os.path.getmtime(makefileAbsolutePath)
        return tmtime



    def generateRootMakeFiles(self, sourcesDict, toolchainNode, configNode, outputFolder, outputSubFolder):

        artefactName = configNode.getArtefactNameRecursive()
        artefactExtension = configNode.getArtefactExtensionRecursive()
        if artefactExtension == None:
            artefactExtension = 'elf'
        
        artefactFileName = '{0}.{1}'.format(artefactName, artefactExtension)
        
        makefileAbsolutePath = os.path.join(outputFolder, outputSubFolder, 'makefile')
        
        if self.verbosity > 0:
            if not os.path.isfile(makefileAbsolutePath):
                print('Write file \'{0}\''.format(makefileAbsolutePath))
            else:
                print('Overwrite file \'{0}\''.format(makefileAbsolutePath))

        f = open(makefileAbsolutePath, 'w')
        
        self.generateDoNotEditMessage(f)

        makeObjectsVariable = toolchainNode.getPropertyRecursiveWithDefault('makeObjectsVariable')

        objectsVariablesList = ''
        # eventually generate objects, ordered by priorities
        prioritiesList = self.getPrioritiesList(sourcesDict)
        for priority in prioritiesList:
            objectsVariablesList += '$({0}_{1:02d}) '.format(makeObjectsVariable, priority)

        objectsVariablesList += '$({0}) '.format(makeObjectsVariable)
            
        f.write('\n')
        f.write('-include makefile_init.mk\n')        
        f.write('\n')
        f.write('-RM := {0} -rf\n'.format('rm'))        
        f.write('\n')

        f.write('# The default target\n')
        f.write('all: {0} secondary-outputs\n'.format(artefactFileName))
        f.write('\n')

        f.write('# Initialise variables to collect sources\n')              
        f.write('CPP_SRCS :=\n')
        f.write('C_SRCS :=\n')
        f.write('S_SRCS :=\n')
        f.write('\n')
        f.write('# Initialise variables to collect dependencies\n')
        f.write('CPP_DEPS :=\n')
        f.write('C_DEPS :=\n')
        f.write('S_DEPS :=\n')
        f.write('\n')
        f.write('# Initialise variables to collect objects\n')
        for priority in prioritiesList:
            f.write('{0}_{1:02d} :=\n'.format(makeObjectsVariable, priority))
        f.write('{0} :=\n'.format(makeObjectsVariable))        
        f.write('\n')

        # TODO: check why this is needed
        f.write('# Subfolders with source files\n')
        f.write('SUBDIRS := \\\n')

        for folder in sourcesDict.iterkeys():
            f.write('{0} \\\n'.format(self.expandPathSpaces(folder)))        
        f.write('\n')
        
        f.write('# Include subfolder build definitions\n')
        for folder in sourcesDict.iterkeys():
            subdirMkRelativePath = os.path.join(folder, 'subdir.mk')
            f.write('-include {0}\n'.format(self.expandPathSpaces(subdirMkRelativePath)))        

        f.write('\n')

        f.write('USER_OBJS :=\n')
        f.write('LIBS :=\n')
        f.write('CUSTOM_EXECUTABLES :=\n')
        f.write('\n')

        f.write('ifneq ($(MAKECMDGOALS),clean)\n')
        f.write('ifneq ($(strip $(CPP_DEPS)),)\n')
        f.write('-include $(CPP_DEPS)\n')
        f.write('endif\n')
        f.write('ifneq ($(strip $(C_DEPS)),)\n')
        f.write('-include $(C_DEPS)\n')
        f.write('endif\n')
        f.write('ifneq ($(strip $(S_DEPS)),)\n')
        f.write('-include $(S_DEPS)\n')
        f.write('endif\n')
        f.write('endif\n')
        f.write('\n')
        
        f.write('-include makefile_defs.mk\n')
        f.write('\n')

        f.write('# Add inputs and outputs from these tool invocations to the build variables\n')
        f.write('\n')

        tool = toolchainNode.getToolRecursive('ld')
        if tool == None:
            print 'No linker define for toolchain \'\', using defaults'.format(toolchainNode.getName())
            
            toolDesc = 'Default g++'
            toolPgmName = 'g++'
        else:           
            toolDesc = tool.getDescription()
            toolPgmName = toolchainNode.getToolProgramNameRecursiveWithSubstitutions('ld')
        
        linkerMiscOptions = toolchainNode.getPropertyRecursiveWithDefault('linkerMiscOptions')
            
        toolOptions = tool.getOptions()
        if toolOptions == None:
            toolOptions = ''  # empty default tool options

        f.write('# Tool invocations\n')
        f.write('{0}: {1}$(USER_OBJS)\n'.format(artefactFileName, objectsVariablesList))
        f.write('\t@echo \'Linking XCDL target: $@\'\n')
        f.write('\t@echo \'Invoking: {0}\'\n'.format(toolDesc))
        
        f.write('\t{0}'.format(toolPgmName));
        
        buildTargetCpuOptions = configNode.getBuildTargetCpuOptionsRecursive()
        if buildTargetCpuOptions != None:
            f.write(' {0}'.format(buildTargetCpuOptions))
        
        compilerCpu = toolchainNode.getPropertyRecursive('compilerCpu')
        if compilerCpu != None:
            f.write(' {0}'.format(compilerCpu))

        compilerDebugOptions = toolchainNode.getPropertyRecursive('compilerDebugOptions')
        f.write(' {0}'.format(compilerDebugOptions))
            
        f.write(' {0}'.format(linkerMiscOptions))
        f.write(' {0}'.format(toolOptions))
        f.write(' -o "{0}"'.format(artefactFileName))
                
        f.write(' {0}'.format(objectsVariablesList))
        f.write('$(USER_OBJS) $(LIBS)\n')
        
        f.write('\t@echo \'Finished linking target: $@\'\n')
        f.write('\t@echo \' \'\n')
        f.write('\n')

        if self.verbosity > 0:
            print '- link \'{0}\' with \'{1}\''.format(artefactFileName, toolDesc)

        runArguments = ' '.join(self.runArguments)
        
        # Run only when there is no target cpu defined
        if buildTargetCpuOptions == None:        
            f.write('# Run Target\n')
            f.write('run: {0}\n'.format(artefactFileName))
            f.write('\t@echo \'Running XCDL target: {0} {1}\'\n'.format(artefactFileName, runArguments))
            f.write('\t@./{0} {1}\n'.format(artefactFileName, runArguments))
            f.write('\t@echo \'Finished running target: {0}\'\n'.format(artefactFileName))
            f.write('\t@echo \' \'\n')
            f.write('\n')
        
        f.write('# Other Targets\n')
        f.write('clean:\n')
        f.write('\t-$(RM) {0}$(CPP_DEPS) $(C_DEPS) $(S_DEPS) $(CUSTOM_EXECUTABLES) {1}\n'.format(objectsVariablesList, artefactFileName))
        f.write('\t@echo \' \'\n')
        f.write('\n')
        
        f.write('secondary-outputs: $(CUSTOM_EXECUTABLES)\n')
        f.write('\n')

        f.write('.PHONY: all run clean dependents\n')
        f.write('.SECONDARY:\n')
        f.write('\n')

        f.write('-include makefile_targets.mk\n')
        f.write('\n')
        
        f.close()
        
        return
    
    
    def getPrioritiesList(self, sourcesDict):
        
        prioritiesDict = {}
        
        # enumerate all sources, search for linkPriority and add it to a dict
        for key in sourcesDict.iterkeys():
            for source in sourcesDict[key]:
                node = source['repoNode']
                linkPriority = node.getLinkPriority()
                if linkPriority != None:
                    prioritiesDict[linkPriority] = None
        
        # sort priorities            
        return sorted(prioritiesDict.keys())
    
    

# ----- functions used in xcdl expressions ------------------------------------

globalCount = 0

def clearGlobalCount():
    
    global globalCount
    globalCount = 0
    return


def getGlobalCount():
    
    global globalCount
    return globalCount

def addToGlobalCount(value):

    global globalCount
    globalCount += value
    return
    
    
def enable(sid):
        
    if CommonApplication.getVerbosity() > 1:
        print 'enable("{0}")'.format(sid)
        
    if CommonApplication.isObjectById(sid):
        node = CommonApplication.getObjectById(sid)
    else:
        if CommonApplication.isObjectBySymbol(sid):
            node = CommonApplication.getObjectBySymbol(sid)
        else:  
            CommonApplication.reportError('Node not found, enable("{0}") ignored'.format(sid))
            return False
    
    if not node.isLoaded():
        CommonApplication.reportError('Node \'{0}\' is not loaded, enable("{1}") ignored'.format(node.getName(), sid))
        return False

    if not node.isConfigurableEvaluated():
        CommonApplication.reportError('Node \'{0}\' is not configurable, enable("{1}") ignored'.format(node.getName(), sid))
        return False
        
    # count = node.setIsEnabledWithCount()
    count = node.setIsEnabledWithCountRecursive()

    if count > 0 and CommonApplication.getVerbosity() > 0:
        symbolName = node.getHeaderDefinition()
        if symbolName != None:
            print '- {0} \'{1}\' ({2}) and parents enabled'.format(node.getObjectType().lower(), node.getName(), symbolName)
        else:
            print '- {0} \'{1}\' and parents enabled'.format(node.getObjectType().lower(), node.getName())
        
    addToGlobalCount(count)
    
    return True


def disable(sid):
        
    if CommonApplication.isObjectById(sid):
        node = CommonApplication.getObjectById(sid)
    else:   
        if CommonApplication.isObjectBySymbol(sid):
            node = CommonApplication.getObjectBySymbol(sid)
        else:  
            CommonApplication.reportError('Node not found, disable("{0}") ignored'.format(sid))
            return False
    
    if not node.isLoaded():
        CommonApplication.reportError('Node \'{0}\' is not loaded, disable("{1}") ignored'.format(node.getName(), sid))
        return False

    if not node.isConfigurableEvaluated():
        CommonApplication.reportError('Node \'{0}\' is not configurable, disable("{1}") ignored'.format(node.getName(), sid))
        return False
        
    count = node.setIsEnabledWithCount(False)

    if count > 0 and CommonApplication.getVerbosity() > 0:
        symbolName = node.getHeaderDefinition()
        if symbolName != None:
            print '- {0} \'{1}\'/{2} disabled'.format(node.getObjectType().lower(), node.getName(), symbolName)
        else:
            print '- {0} \'{1}\' disabled'.format(node.getObjectType().lower(), node.getName())
        
    addToGlobalCount(count)
    
    return True


def isEnabled(sid):
        
    if CommonApplication.isObjectById(sid):
        node = CommonApplication.getObjectById(sid)
    else:
        if CommonApplication.isObjectBySymbol(sid):
            node = CommonApplication.getObjectBySymbol(sid)
        else:  
            CommonApplication.reportError('Node not found, isEnabled("{0}") return False'.format(sid))
            return False
        
    return node.isEnabled()


def isActive(sid):
        
    if CommonApplication.isObjectById(sid):
        node = CommonApplication.getObjectById(sid)
    else:
        if CommonApplication.isObjectBySymbol(sid):
            node = CommonApplication.getObjectBySymbol(sid)
        else:  
            CommonApplication.reportError('Node not found, isActive("{0}") return False'.format(sid))
            return False
        
    return node.isActive()


def valueOf(sid):
        
    if CommonApplication.isObjectById(sid):
        node = CommonApplication.getObjectById(sid)
    else:
        if CommonApplication.isObjectBySymbol(sid):
            node = CommonApplication.getObjectBySymbol(sid)
        else:  
            CommonApplication.reportError('Node not found, valueOf("{0}") return 0'.format(sid))
            return False
        
    return node.getValueWithType()


def setValue(sid, value):
        
    if CommonApplication.getVerbosity() > 1:
        print 'setValue("{0}", \'{1}\')'.format(sid, value)

    if CommonApplication.isObjectById(sid):
        node = CommonApplication.getObjectById(sid)
    else:  
        if CommonApplication.isObjectBySymbol(sid):
            node = CommonApplication.getObjectBySymbol(sid)
        else:  
            CommonApplication.reportError('Node not found, setValue("{0}") ignored'.format(sid))
            return False
    
    if not node.isConfigurableEvaluated():
        CommonApplication.reportError('Node \'{0}\' is not configurable, setValue("{1}") ignored'.format(node.getName(), sid))
        return False

    if node.getValueTypeWithDefault() == 'none':
        CommonApplication.reportError('Node \'{0}\' has valueType=\'none\', setValue("{1}") ignored'.format(node.getName(), sid))
        return False
    
    count = node.setValueWithCount(value)
    
    if count > 0 and CommonApplication.getVerbosity() > 0:
        symbolName = node.getHeaderDefinition()
        if symbolName != None:
            print '- {0} \'{1}\' ({2}) set to "{3}"'.format(node.getObjectType().lower(), node.getName(), symbolName, value)
        else:
            print '- {0} \'{1}\' set to "{2}"'.format(node.getObjectType().lower(), node.getName(), value)

    addToGlobalCount(count)
    
    return True


def implementationsOf(sid):
    
    if CommonApplication.getVerbosity() > 1:
        print 'implementationsOf("{0}")'.format(sid)

    if not CommonApplication.isObjectById(sid):
        CommonApplication.reportError('Node not found, implementationsOf("{0}") returns 0'.format(sid))
        return 0
    
    node = CommonApplication.getObjectById(sid)
    if node.getObjectType() != 'Interface':
        CommonApplication.reportError('Node \'{0}\' not an interface, implementationsOf("{1}") returns 0'.format(node.getName(), sid))
        return 0
        
    nodeValue = node.getValue()
    if CommonApplication.getVerbosity() > 1:
        print 'implementationsOf("{0}")={1}'.format(sid, nodeValue)
    
    return nodeValue




